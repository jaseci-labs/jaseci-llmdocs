You are assembling a Jac language reference. Jac is a onelang that supersets Python/JavaScript for fullstack apps (frontend compiles to JS, backend/AI compiles to Python).

HARD TARGET: 18-22KB. You MUST stay under 22KB. Count your output size. If you exceed 22KB, you have failed.

OUTPUT FORMAT: Dense plain text with # headers and ```jac fenced code blocks. NO markdown tables. NO verbose prose. One line per concept. Semicolons to group related items. WRONG/RIGHT as inline pairs, not tables.

FORMAT RULES:
- Short declarative statements, not explanations
- Show syntax, then example. No "as in" or "for example"
- Group related items with semicolons on ONE line
- Use ```jac fenced code blocks for multi-line code examples and patterns
- Inline code with backticks for single-line syntax references
- One line per concept where possible
- WRONG/RIGHT pairs: show only the code, minimal words
- Patterns: 3 patterns max, each under 80 lines. No verbose comments.
- Error list: plain text lines, not markdown tables
- Maximize information per token. Every line must teach something.

HIGH-FAILURE SYNTAX (must be exact -- verified with jac check):
- CLI: jac start file.jac (not jac serve); jac check file.jac (may have false positives/negatives)
- Top-level: only declarations allowed. Executable statements MUST go inside with entry { } or a function body.
- Entry: with entry { } not entry { }
- Spawn: BOTH forms valid: root spawn Walker(); AND Walker() spawn root; (use root or variable, NEVER bare keyword node)
- Import: import from module { sym } (NO semicolon after }); import module; (semicolon for plain import). Wrong: import from math, sqrt; No import:py or import:jac exists.
- Packages: __init__.jac required (like Python). include in __init__.jac: FULL dotted paths. WRONG: include nodes; (passes check, fails runtime). RIGHT: include mypackage.nodes;
- LLM: def f() -> T by llm; OR by llm(); both valid. by llm(temperature=0.7) for params. No import needed.
- Semstrings: has desc: str = "" """hint for LLM"""; default value required before hint
- sem annotations: sem Obj.field = "description"; for guiding LLM output
- Model: import from byllm.lib { Model }; glob llm = Model(model_name="gpt-4o-mini");
- Access: has:priv x OR has :priv x (both valid); only :pub :priv :protect
- Permissions: node.__jac__.grant(root, WritePerm); Levels: NoPerm ReadPerm ConnectPerm WritePerm
- Specs: obj __specs__ { static has methods: list = [...]; } __specs__ controls methods/path/path_prefix/websocket/schedule/webhook ONLY, NOT auth.
- path_prefix: static has path_prefix: str = "/api"; in __specs__
- Walker auth: :pub on walker declaration = public (no auth). Without :pub = requires auth token. WRONG: static has auth: bool = False; in __specs__.
- Auth endpoints: POST /user/register and POST /user/login for built-in auth tokens
- :pub walker root access: READ-ONLY. Graph writes silently fail when here is root. Use built-in auth for write access.
- Custom auth (OAuth/JWT): make ALL walkers :pub, handle auth manually inside walker body.
- Methods: can for abilities (with entry/exit), def for regular methods
- Root type: Root (capital R) in event clauses. Backtick `root REMOVED. Union: can act with Root | MyNode entry { }
- Filters: [-->](?:Type); [-->](?:Type, attr==val). Old (`?Type) REMOVED. Comma separator.
- CLI: jac create --use client (not fullstack); jac add --npm; jac install syncs all; jac start --scale (no -t)
- Optionals: str | None, not str?
- Booleans: True/False (true/false pass syntax but FAIL at runtime)
- Lambdas: Expression: lambda x: int -> int : x * 2; Block: lambda x: int -> int { return x * 2; }; Block REQUIRES return. Expression cannot have assignments.
- Lambda multi-param: lambda x: int, y: int -> int : x + y;
- Lambda as argument: items.sort(key=lambda x: dict -> float : x["v"]);
- Lambda with assignment MUST use block form: lambda e: any -> None { input_val = e.target.value; } NOT expression form
- Empty lambda body: lambda e: any -> None { 0; } NOT {} (empty body fails)
- Tuple unpacking: (a, b) = func(); parens required
- No pass keyword: use {} or comment
- Enumerate: for (i, x) in enumerate(items) { }; parens required
- C-style for: for i=0 to i<10 by i+=1 { stmt; }
- Match/case: case V: stmt; (COLON not braces). Wrong: case 1 { }
- Typed edge CONNECT: a +>: E() :+> b; Wrong: a ++> E() ++> b (++> only untyped)
- Typed edge TRAVERSE: [->:E:->] Wrong: [-->:E:] (--> only untyped)
- Chained: [->:E1:->->:E2:->] Wrong: [-->:E1:->-->:E2:->]
- Edge attr filter: [->:Friend:since > 2020:->]
- Disconnect: a del--> b; Wrong: del a --> b;
- Untyped returns list: a ++> Node() returns list; use [0] for single
- Variable node traversal: [node_var ->:E:->] traverses from specific node
- Globals: glob var: T = val; at module level. Access by name in functions. WRONG: glob counter; inside function body.
- Boolean NOT: `not x` (Python-style). WRONG: `!x` (JavaScript `!` operator does NOT exist in Jac)
- Try/except: try { } except Type as e { } finally { }; except not catch
- Inheritance: obj Child(Parent) { }; walker W(BaseW) { }
- Pipe: "hello" |> print;
- Impl blocks: impl W.ability { code }
- Postinit: has f: T by postinit; def postinit { self.f = val; }
- Walrus: root +>: E() :+> (end := A(val=10));
- Backward typed: a <+: E() :<+ b; [<-:E:<-]
- List concat in cl{}: use items.append(x) not items = items + [x] (cl{} only)
- Reserved keywords: obj node walker edge enum can has -- NEVER use as variable names. WRONG: obj = json.loads(s); RIGHT: data = json.loads(s);
- Attribute ordering: non-default BEFORE default. Wrong: has x: int = 0; has y: str;
- Test names: identifiers not strings. Wrong: test "name" { }
- Fullstack entry: cl{} def:pub app must match [serve] base_route_app in jac.toml
- .cl.jac auto client-side (no cl{} wrapper). Do NOT include via include.
- Dev ports: --port Vite frontend (8000); --api_port backend (8001, auto-proxied)
- No ternary ?: -- use (expr) if cond else (expr)
- cl{} JS builtins: .length not len(); String(x) not str(x); parseInt(x) not int(x); Math.min/max; .trim() not .strip(); no range(); no f-strings (use +); no tuple unpacking; no new keyword; className not class
- sv import prefix for server imports in .cl.jac
- Lifecycle: useEffect(lambda -> None { func(); }, []) not can with entry
- root spawn compiles to await; function MUST be async def
- root spawn sends POST; walker __specs__ MUST include "POST"
- CSS: import "./styles.css";
- .jac/ auto-generated, never modify manually
- npm deps: ALL in jac.toml; NEVER npm install in .jac/client/
- Tailwind v4: tailwindcss + @tailwindcss/postcss in [dependencies.npm]
- .env: not auto-loaded; use glob _: bool = load_dotenv() or True;
- Docstrings go BEFORE declarations, not inside bodies. Never name abilities list/dict/str/int or other builtins.
- report: appends to .reports array. Access: result = root spawn W(); data = result.reports[0]; Always check .reports before indexing. Prefer single report in with Root exit.
- visit: QUEUES nodes for next traversal step (NOT immediate). Code after visit continues executing. visit [-->] else { fallback; } for dead ends. visit specific node: visit self.target; Indexed: visit : 0 : [-->];
- disengage: immediately terminates walker traversal (walker's return). After disengage, exit abilities for ancestor nodes will NOT execute (v0.9.8+). Use when search found target.
- skip: skips remaining code in current node's ability, moves to next queued node. Like continue for walker traversal.
- with entry:__main__: only runs when file executed directly (Jac's if __name__ == "__main__"). with entry { } always runs when module loads.
- include = C-style merge into current scope (inlines code). import = Python-style namespace separation.
- flow/wait: flow launches function as background task (thread pool), returns future. wait retrieves result (blocks if needed). Use for CPU-bound parallel tasks. async/await = event loop, for I/O-bound.
- Walker access: walker:priv W {} or walker :pub W {}. :pub = public endpoint. Without :pub = requires auth.
- Walker traversal is recursive DFS with deferred exits (v0.9.8+). Entries execute depth-first, exits in LIFO order (post-order). root->A->B: Enter root, Enter A, Enter B, Exit B, Exit A, Exit root.
- JSX comprehensions: {[<li>{item}</li> for item in items]} compiles to .map(). Also: {[<li>{x}</li> for x in items if x.active]} compiles to .filter().map().
- Websocket: socket.notify_users(ids, msg); socket.notify_channels(names, msg); broadcast=True for broadcasting. Remove :pub for authenticated websocket.
- Webhook: obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Sig"}; }
- Scheduler: static has private: bool = True; for private scheduled tasks. Triggers: cron interval date
- Persistence: nodes connected to root auto-persist. save(node); commit(); &id for reference; del node; commit();
- Deploy: jaseci for full runtime (persistence/auth plugins). jaclang for compiler-only. Env: DATABASE_URL JAC_SECRET_KEY

TOPICS (26 sections -- keep each CONCISE, 3-8 lines max per section):

1. TYPES: primitives; collections; unions; has; return types; attribute ordering
2. CONTROL: if/elif/else; for (both forms); for (i,x) in enumerate; while; match/case (colon!); try/except (not catch); no ternary; no pass
3. FUNCTIONS: def; lambda (expression + block + multi-param + as-argument + assignment-must-block + empty-body); pipe; f-strings; glob; top-level restriction; docstrings before decl
4. IMPORTS: import (namespace); import from { }; include (inline merge); __init__.jac full dotted paths; wrong forms; with entry / with entry:__main__
5. ARCHETYPES: node; edge; walker; obj; enum; inheritance; impl; postinit; can vs def; reserved keywords; boolean NOT is `not x` (NOT `!x`)
6. ACCESS: :pub :priv :protect on has/def/can/walker
7. GRAPH: connect (typed/untyped); disconnect; traversal (typed/untyped); filters (type/attr/edge -- always assign to variable, never bare); variable node traversal; walrus; visit indexed; untyped returns list
8. ABILITIES: can with entry/exit; self/here/visitor; Root type (capital R); union types
9. WALKERS: spawn (both forms); visit (queued, not immediate); visit else {}; report (.reports array); disengage (exits skipped); skip; DFS traversal order
10. BY_LLM: by llm; semstrings (has desc: str = "" """hint""";); sem annotations (put OUTSIDE fenced code blocks or comment them); enum classification; Model import; inline by llm
11. FILE_JSON: file.open; json.dumps/loads; keyword variable warning (obj is keyword)
12. API: jac start; walker endpoints; __specs__ (methods/path/path_prefix); :pub auth; auth endpoints (/user/register, /user/login); read-only root; custom auth (OAuth/JWT pattern)
13. WEBSOCKET: __specs__ methods=["websocket"]; async walker; ws:// endpoint; notify_users/notify_channels; broadcast
14. WEBHOOKS: __specs__ webhook dict; endpoint path
15. SCHEDULER: __specs__ schedule dict; private; triggers (cron/interval/date)
16. ASYNC: async walker; async def; flow/wait (thread pool for CPU-bound); async/await (event loop for I/O-bound); task status
17. PERMISSIONS: grant/revoke/check_access; NoPerm ReadPerm ConnectPerm WritePerm
18. PERSISTENCE: auto-persist; save; commit; &id references; delete
19. TESTING: test name { assert }; identifier names
20. STDLIB: builtins; string/list/dict methods
21. JSX/CLIENT: .cl.jac; sv import; useEffect; async def + root spawn; JS builtins; className; CSS; component def:pub; has = reactive state; JSX comprehensions; conditional rendering; form handling; component imports; .cl.jac auto-compiled, never include
22. CLIENT_AUTH: jacSignup/jacLogin/jacLogout/jacIsLoggedIn from @jac/runtime; per-user isolation
23. JAC.TOML: all sections ([project] [dependencies] [dependencies.npm] [serve] [plugins.client] [build] [scripts]); tailwind config; npm deps
24. FULLSTACK_SETUP: jac create --use client; jac install; jac add --npm; .jac/ auto-gen; project structure; __init__.jac dotted paths
25. DEV_SERVER: jac start --dev; ports (--port frontend, --api_port backend); proxy (/walker/* /function/* /user/*); --no-client
26. DEPLOY_ENV: Dockerfile example; jaseci vs jaclang; jac start --scale; env vars (DATABASE_URL JAC_SECRET_KEY); .env loading via glob trick; import from os { getenv }

PATTERNS (include 3 complete examples, each COMPACT -- under 80 lines):

PATTERN 1: Fullstack single-file (main.jac with sv{}/cl{})
- Counter app: node, typed edge, 2 walkers (GetCount, Increment) with __specs__ and :pub
- sv{} block: import from __main__ { GetCount, Increment, Counter }
- cl{} block: import from react { useEffect }; sv import from __main__ { GetCount, Increment }; def:pub app with useEffect, async def, JS builtins
- Show jac.toml. This is the actual fullstack wiring pattern.
- with entry { } for initial graph setup

PATTERN 2: Walker graph traversal
- Cities/Roads graph. TWO separate focused walkers:
  - FindReachable: Root entry visits [-->], City entry appends + visits [->:Road:->], Root exit reports
  - DeleteRoute: takes from_city/to_city, visits filtered nodes, uses del-->
- with entry block: creates cities, typed connects, traversal from variable node, edge attr filter, spawn both walkers
- Show [node_var ->:Road:->] and [node_var ->:Road:toll == True:->]

PATTERN 3: API endpoints with __specs__
- Todo CRUD: ListTodos (GET+POST with path_prefix), AddTodo, FilterTodos (match/case for priority filter)
- Show __specs__ with methods, path_prefix
- Show :pub auth, realistic walker structure
- Keep compact, no client code in this pattern

COMMON ERRORS: ~30 lines, plain text WRONG -> RIGHT format. Include ALL of these:
- true/false -> True/False
- entry { } -> with entry { }
- import from math, sqrt; -> import from math { sqrt }
- import:py from os { path } -> import from os { path }
- node spawn W(); -> root spawn W(); (node is keyword)
- a ++> Edge() ++> b; -> a +>: Edge() :+> b;
- [-->:E:] -> [->:E:->]
- [-->:E1:->-->:E2:->] -> [->:E1:->->:E2:->]
- del a --> b; -> a del--> b;
- (`?Type) -> (?:Type)
- (`?Type:attr>v) -> (?:Type, attr > v)
- can act with `root entry -> can act with Root entry
- test "name" { } -> test name { }
- obj = json.loads(s); -> data = json.loads(s);
- str? -> str | None
- jac serve file.jac -> jac start file.jac
- jac create --use fullstack -> jac create --use client
- static has auth: bool = False; -> walker :pub W { }
- <div class="x"> -> <div className="x">
- len(items) in cl{} -> items.length
- str(x) in cl{} -> String(x)
- f"Hello {x}" in cl{} -> "Hello " + x
- items = items + [x] in cl{} -> items.append(x)
- lambda e: any -> None {} -> lambda e: any -> None { 0; }
- include nodes; in __init__.jac -> include mypackage.nodes;
- npm install in .jac/client/ -> jac add --npm pkgname
- print("x"); at top level -> with entry { print("x"); }
- case 1 { stmt; } -> case 1: stmt;
- catch Error as e { } -> except Error as e { }
- result = x > 0 ? "y" : "n"; -> result = ("y") if x > 0 else ("n");
- has x: int = 0; has y: str; -> has y: str; has x: int = 0;
- glob counter; inside function -> just use counter directly
- result.returns[0] -> result.reports[0]
- .map(lambda x -> ...) in JSX -> {[<li>{x}</li> for x in items]}
- pass -> {} or comment
- !x (JS-style NOT) -> not x (Python-style NOT)
- sem annotations and semstrings are COMMENTS for LLM guidance -- put them outside fenced code blocks or prepend with # inside code

---

EXTRACTED CONTENT:
{content}

---

VERIFIED SYNTAX (ground truth -- use these exact forms):

# Typed edges
a +>: E(weight=0.5) :+> b; # Connect
[->:E:->] # Traverse
[->:E1:->->:E2:->] # Chained
a <+: E() :<+ b; # Backward connect
[<-:E:<-] # Backward traverse
a del--> b; # Disconnect

# Filters (must be assigned or used in expression -- NOT bare statements)
nodes = [-->](?:MyNode); # Type filter
adults = [-->](?:MyNode, age > 18); # Type + attr
old = [-->](?age > 18); # Untyped attr
friends = [->:Friend:since > 2020:->]; # Edge attr

# Variable node traversal
neighbors = [city_a ->:Road:->];
untyped = [node_var -->];

# Match/case
match x { case 1: print("one"); case _: print("other"); }

# Lambda forms
f = lambda x: int -> int : x * 2; # Expression
f = lambda x: int -> int { return x * 2; }; # Block (MUST return)
g = lambda x: int, y: int -> int : x + y; # Multi-param
items.sort(key=lambda x: dict -> float : x["v"]); # As argument
lambda e: any -> None { input_val = e.target.value; } # Assignment = block form
lambda e: any -> None { 0; } # Empty body (not {})

# Spawn
root spawn W(); W() spawn root; # Both valid

# Import (NO semicolon after import from { })
import os;
import from math { sqrt }

# Walrus
root +>: E() :+> (end := A(val=10));

# Visit (queued, not immediate)
visit [-->];                          # Queue outgoing nodes
visit [->:Road:->];                   # Queue via typed edge
visit [-->] else { print("leaf"); }   # Fallback for dead ends
visit self.target;                    # Visit specific node
visit : 0 : [-->];                    # Visit first only

# Test
test my_test { assert 1 + 1 == 2; }

# Postinit
obj MyObj { has x: int = 0; has y: int by postinit; def postinit { self.y = self.x * 2; } }

# Glob
glob counter: int = 0;
def increment() -> int { counter += 1; return counter; }

# report (.reports array)
# result = root spawn W();
# data = result.reports[0];
# Safe: data = result.reports[0] if result.reports else None;

# disengage / skip
# disengage;  -- stops walker. Exit abilities for ancestors will NOT run.
# skip;       -- skips to next queued node (like continue)

# Entry point variants
# with entry { print("always runs"); }
# with entry:__main__ { print("only when this file is main"); }

# include vs import
# include utils;                         # Merges utils.jac into current scope
# import math;                           # Namespace import
# import from math { sqrt }              # Selective import

# flow/wait
# future = flow expensive_fn();
# result = wait future;
# async/await = event loop (I/O). flow/wait = thread pool (CPU).

# JSX comprehensions
# {[<li>{item}</li> for item in items]}
# {[<li>{x}</li> for x in items if x.active]}

# cl{} patterns
# sv import from walkers { W }
# useEffect(lambda -> None { myAsyncFunc(); }, []);
# className not class; .length not len(); String(x) not str(x)

# Routing
# import from "@jac/runtime" { Router, Routes, Route, Link, Navigate, useNavigate }

# Client auth
# import from "@jac/runtime" { jacSignup, jacLogin, jacLogout, jacIsLoggedIn }

# Semantic annotations
# sem Analysis.sentiment = "overall emotional tone";
# has desc: str = "" """hint for LLM""";
# glob llm = Model(model_name="gpt-4o-mini");

# Websocket
# async walker :pub Echo { obj __specs__ { static has methods: list = ["websocket"]; } async can echo with Root entry { report here; } }
# socket.notify_users(ids, msg); socket.notify_channels(names, msg);

# Webhook
# obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Sig"}; }

# Scheduler
# obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9"}; static has private: bool = True; }

# :pub walker read-only root
# walker :pub ReadOnly { can read with Root entry { report [-->]; } } # OK
# walker :pub WriteAttempt { can write with Root entry { here +>: E() :+> N(); } } # Silently fails!

# .env loading
# import from dotenv { load_dotenv }
# import from os { getenv }
# glob _: bool = load_dotenv() or True;

# Deploy
# FROM python:3.11-slim
# RUN pip install jaseci
# COPY . /app
# CMD ["jac", "start", "main.jac"]
# Env: DATABASE_URL JAC_SECRET_KEY OPENAI_API_KEY

# jac.toml (all sections)
# [project]
# name = "myapp"
# entry-point = "main.jac"
# [dependencies]
# python-dotenv = ">=1.0.0"
# [dependencies.npm]
# jac-client-node = "1.0.4"
# [dependencies.npm.dev]
# "@jac-client/dev-deps" = "1.0.0"
# [serve]
# base_route_app = "app"
# port = 8000
# [plugins.client]
# port = 5173

# Persistence
# save(node); commit(); &id for reference; del node; commit();

# Async task status
# task.__jac__.status; task.__jac__.reports; task.__jac__.error;

# path_prefix
# obj __specs__ { static has methods: list = ["GET"]; static has path_prefix: str = "/api"; }

---

Generate terse reference. Use # headers for topics, ```jac blocks for code. Every code example MUST use verified syntax above. 26 topics + errors list + 3 patterns. HARD LIMIT: 22KB max. Match candidate.txt density (~500 lines / 18-20KB). Maximize information per token.

GOLDEN STYLE (match this density -- dense prose, no wasted lines):

# 1. TYPES
int float str bool bytes any; list[T] dict[K,V] set[T]; int|None for optionals (NOT int?)
has x: int; has y: str = "default"; -> ReturnType for function returns
True/False capitalized (true/false pass syntax check but FAIL at runtime)
Non-default attributes MUST come before default attributes in same archetype
WRONG: node N { has x: int = 0; has y: str; }
RIGHT: node N { has y: str; has x: int = 0; }

# 7. GRAPH
```jac
a ++> b;                              # Untyped forward
a +>: Friend(since=2020) :+> b;       # Typed forward
[->:Friend:->]                        # Typed traversal
a del--> b;                           # Disconnect
people = [-->](?:Person);              # Type filter
adults = [-->](?:Person, age > 18);    # Type+attr filter
```
Untyped returns list: nodes = root ++> Person(); first = nodes[0];
WRONG: a ++> Edge() ++> b; [-->:E:] del a --> b;
