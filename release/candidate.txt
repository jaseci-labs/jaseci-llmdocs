# JAC LANGUAGE REFERENCE

## 1. TYPES

Primitives: int float str bool bytes any
Containers: list[T] dict[K,V] set[T] tuple[T,...]
Unions: int|None str|None (not str?)
Declaration: has x: int; has y: str = "default"
Return: def f() -> int { }
Booleans: True False (capitalized, not true/false)
None: None (capitalized)

## 2. CONTROL

If: if cond { } elif cond { } else { }
For-in: for x in items { }
For-range: for i=0 to i<10 by i+=1 { }
While: while cond { }
Match: match x { case 1 { } case 2 { } case _ { } }
Enumerate: for (i, x) in enumerate(items) { } (parentheses required)
Tuple unpack: (a, b) = func(); (parentheses required on left)
No pass: use {} or # comment for empty blocks
Break/continue: break; continue;

## 3. FUNCTIONS

Regular: def name(p: T) -> R { return val; }
Lambda: lambda x: int -> int { x * 2 }
Lambda typed: lambda x: int, y: str -> bool { len(y) > x }
Global: glob config: dict = {"key": "val"};
Docstring: """desc""" def f() { } (before declaration)
Wrong: def f() { """doc""" } Right: """doc""" def f() { }

## 4. IMPORTS

Module: import os;
Symbol: import from math { sqrt }
Alias: import from datetime { datetime as dt }
Multiple: import from module { a, b, c }
Include: include submodule;
Package: requires __init__.jac (like Python __init__.py)
Wrong: import from math { sqrt }; Right: import from math { sqrt }
Wrong: import:py os Right: import os

## 5. ARCHETYPES

Node: node N { has f: T; def m() { } can on_v with W entry { } }
Edge: edge E { has weight: float; }
Walker: walker W { has s: T; can act with N entry { visit [-->]; } }
Object: obj O { has f: T; def m() { } }
Enum: enum E { A, B=1, C="val" }
Enum methods: enum E { A ::py:: def method(self): pass ::py:: }

## 6. ACCESS

Private: has:priv f: T; def:priv m() { }
Public: has:pub f: T; def:pub m() { }
Protected: has:protect f: T; can:protect h with entry { }
Only three: :pub :priv :protect
Wrong: has :priv x Right: has:priv x (no space)

## 7. GRAPH

Connect: a ++> b; (returns list)
Bidirectional: a <++> b;
Typed edge: a ++> EdgeType() ++> b; (edge must be instantiated)
Alternative typed: a +>: EdgeType() :+> b;
Disconnect: del a --> b;
Forward query: [-->]
Back query: [<--]
Typed traversal: [-->:E:]
Filter type: [-->(`?Node)]
Filter attr: [-->](?attr > val)
Chained: [-->:Friend:->-->:Colleague:->]
Edge filter: [->:Friend:since > 2020:->]
Wrong: a +>:EdgeType:+> b Right: a ++> EdgeType() ++> b
Connection returns list: nodes = a ++> Node(); single = nodes[0];

## 8. ABILITIES

Entry: can name with Type entry { }
Exit: can name with Type exit { }
Generic: can name with entry { }
Always requires: with...entry or with...exit
Use def for regular methods: def calculate() -> int { }
Use can for node/walker interactions: can process with Item entry { }
Context vars: self=instance here=node visitor=walker root=user_root
Wrong: can name { } Right: can name with Type entry { }
Never name abilities: list dict str int get set (use fetch handle process)

## 9. WALKERS

Spawn: node spawn Walker(); (node first, then spawn)
Visit: visit [-->];
Visit else: visit [-->] else { print("no nodes"); }
Report: report value;
Disengage: disengage; (stop walker completely)
Skip: skip; (skip to next node)
Get reports: result = node spawn Walker(); data = result.reports;
Wrong: spawn Walker() on node Right: node spawn Walker()
Wrong: Walker().spawn(node) Right: node spawn Walker()

Example:
node Item { has name: str; }
walker Collector { has items: list = []; can gather with Item entry { self.items.append(here.name); } can finish with `root exit { report self.items; } }
with entry { root ++> Item(name="A"); root ++> Item(name="B"); result = root spawn Collector(); print(result.reports[0]); }

## 10. BY_LLM

Basic: def f(x: str) -> str by llm;
Structured: def f() -> MyObj by llm;
With params: def f() -> str by llm(temperature=0.7);
With method: def f() -> str by llm(method="Reason");
Semstring: has desc: str = "" """hint for LLM""";
Inline: result = "prompt" by llm;
Stream: def f() -> str by llm(stream=True);
No import needed: by llm is builtin
Wrong: by llm() Right: by llm; (semicolon, no parens)
Wrong: by llm("prompt") Right: "prompt" by llm

Example:
enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL }
def analyze(text: str) -> Sentiment by llm;
with entry { result = analyze("I love this!"); }

## 11. FILE_JSON

Open: f = file.open(path, "r");
Read: content = f.read();
Write: f.write(data);
Close: f.close();
JSON encode: s = json.dumps(obj);
JSON decode: obj = json.loads(s);

## 12. API

Start server: jac start file.jac (not jac serve)
Check syntax: jac check file.jac
Walker as endpoint: walker becomes HTTP endpoint automatically
Specs object: obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = True; static has path_prefix: str = "/api"; }
Wrong: __specs__ = {"methods": ["GET"]} Right: obj __specs__ { static has methods: list = ["GET"]; }

Example:
walker GetItems { obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = False; } can fetch with `root entry { report {"items": [1,2,3]}; } }

## 13. WEBSOCKET

Spec: obj __specs__ { static has methods: list = ["websocket"]; }
Notify users: socket.notify_users(user_ids, message);
Notify channels: socket.notify_channels(channel_names, message);

## 14. WEBHOOKS

Spec: obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Signature"}; }
Endpoint: /webhook/walker/walker_name

## 15. SCHEDULER

Cron: obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9"}; static has private: bool = True; }
Interval: static has schedule: dict = {"trigger": "interval", "minutes": "30"};
Date: static has schedule: dict = {"trigger": "date", "run_date": "2024-01-01"};

## 16. ASYNC

Async walker: async walker W { async can f with entry { await op(); } }
Async function: async def fetch() -> str { return await http_get(url); }
Task status: task.__jac__.status task.__jac__.reports task.__jac__.error

## 17. PERMISSIONS

Grant: node.__jac__.grant(root, WritePerm);
Revoke: node.__jac__.revoke(root);
Check: node.__jac__.check_access(root, ReadPerm);
Levels: NoPerm ReadPerm ConnectPerm WritePerm

## 18. PERSISTENCE

Auto-persist: nodes connected to root persist automatically
Save: save(node);
Commit: commit();
Reference: &node_id
Delete: del node; commit();
Global persist: glob var: T = val;

## 19. TESTING

Test block: test name { assert cond; check cond; }
Run: jac test file.jac

## 20. STDLIB

Builtins: print len range enumerate type str int float list dict set
String: s.upper() s.lower() s.strip() s.split() s.join(list)
List: l.append(x) l.extend(list) l.pop() l.sort()
Dict: d.keys() d.values() d.items() d.get(k, default)

## 21. JSX

Server block: sv { }
Client block: cl { }
Component: def:pub App() -> any { has count: int = 0; return <div>{count}</div>; }
State: has count: int = 0; (auto-reactive)
Mount: can with entry { }
Unmount: can with exit { }
Dependency: can with [dep] entry { }
Multi-dep: can with (a, b) entry { }
Props: def:pub Comp(props: dict) -> any { return <div>{props.name}</div>; }
Event: <button onClick={handler}>Click</button>
Conditional: if cond { return <A />; } return <B />;
List: items.map(lambda x: any -> any { <li>{x}</li> })

Example:
sv { walker GetData { obj __specs__ { static has methods: list = ["GET"]; } can fetch with `root entry { report {"msg": "hello"}; } } }
cl { def:pub App() -> any { has data: dict = {}; async can with entry { data = root spawn GetData(); } return <div>{data.msg}</div>; } }

## 22. DEPLOY

Dockerfile: FROM python:3.11-slim
RUN pip install jaclang
COPY . /app
WORKDIR /app
CMD ["jac", "start", "main.jac"]

Env vars: DATABASE_URL JAC_SECRET_KEY OPENAI_API_KEY

## PATTERNS

### Fullstack Single-File
sv { node Item { has name: str; } walker ListItems { obj __specs__ { static has methods: list = ["GET"]; } can fetch with `root entry { items = [-->(`?Item)]; report [{"name": i.name} for i in items]; } } walker AddItem { has name: str; obj __specs__ { static has methods: list = ["POST"]; } can create with `root entry { root ++> Item(name=self.name); report {"ok": True}; } } }
cl { def:pub App() -> any { has items: list = []; has newName: str = ""; async can with entry { result = root spawn ListItems(); items = result.reports[0] if result.reports else []; } async def addItem() { root spawn AddItem(name=newName); newName = ""; result = root spawn ListItems(); items = result.reports[0]; } return <div><input value={newName} onChange={lambda e: any -> None { newName = e.target.value; }} /><button onClick={addItem}>Add</button><ul>{items.map(lambda i: dict -> any { <li>{i["name"]}</li> })}</ul></div>; } }

### Walker Graph Traversal
node Person { has name: str; has age: int; }
edge Knows { has since: int; }
walker FindFriends { has min_age: int = 0; has found: list = []; can start with `root entry { visit [-->]; } can check with Person entry { if here.age >= self.min_age { self.found.append(here.name); } visit [-->:Knows:]; } can finish with `root exit { report self.found; } }
with entry { p1 = root ++> Person(name="Alice", age=30); p2 = p1[0] ++> Knows(since=2020) ++> Person(name="Bob", age=25); result = root spawn FindFriends(min_age=20); print(result.reports[0]); }

### API Endpoint with Specs
walker CreateUser { has email: str; has name: str; obj __specs__ { static has methods: list = ["POST"]; static has auth: bool = False; static has path_prefix: str = "/api/v1"; } can create with `root entry { user_id = str(uuid4()); root ++> User(id=user_id, email=self.email, name=self.name); report {"id": user_id, "email": self.email, "name": self.name}; } }
walker GetUser { has user_id: str; obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = True; } can fetch with `root entry { users = [-->(`?User)](?id == self.user_id); if users { report {"user": users[0]}; } else { report {"error": "not found"}; } } }

## ENTRY POINT

Module entry: with entry { } (not entry { })
Wrong: entry { code } Right: with entry { code }

## COMMON ERRORS

Wrong: jac serve file.jac Right: jac start file.jac
Wrong: spawn Walker() on node Right: node spawn Walker()
Wrong: entry { } Right: with entry { }
Wrong: import from x { y }; Right: import from x { y }
Wrong: by llm() Right: by llm;
Wrong: has :priv x Right: has:priv x
Wrong: str? Right: str|None
Wrong: true false Right: True False
Wrong: a +>:Edge:+> b Right: a ++> Edge() ++> b
Wrong: pass Right: {} or # comment
Wrong: for i, x in enumerate(items) Right: for (i, x) in enumerate(items)
Wrong: a, b = func() Right: (a, b) = func()
Wrong: can list with entry { } Right: can fetch with entry { }
Wrong: __specs__ = {} Right: obj __specs__ { static has ... }