Jac is a onelang that supersets Python and JavaScript, enabling developers to build fullstack applications with frontend, backend, and AI under one unified language. Jac compiles to Python for backend and AI workloads while compiling to JavaScript for frontend, with seamless interoperability between both targets. Write once, deploy anywhere. The core philosophy eliminates context switching between languages by providing a single syntax for reactive UIs, graph-based data models, walker-based APIs, and LLM-powered AI functions.

SYNTAX AND TYPES: Jac supersets Python syntax with curly braces and an enhanced type system. Primitives include int, float, str, bool, bytes, and any for dynamic typing. Collections use type parameters: list[T], dict[K,V], set[T], tuple[T,...], frozenset[T]. Type unions use the pipe operator: int | None or str | int. Type annotations appear with has for fields (has x: int;) and arrow for return types (-> str). Control flow uses curly braces: if x > 0 { print("positive"); } elif x < 0 { print("negative"); } else { print("zero"); }. The Jac for loop syntax is for i = 0 to i < 10 by i += 1 { print(i); } or the Pythonic for item in items { process(item); }. While loops: while condition { body; }. Match/case for pattern matching: match status { case Status.PENDING { print("Waiting"); } case Status.ACTIVE { print("Active"); } }. CRITICAL: Standalone functions use def: def calculate(x: int, y: int) -> int { return x + y; }. The can keyword is ONLY for abilities with event clauses like can name with Type entry { } or can name with exit { }, never for standalone functions. Lambdas use pipe syntax: |x: int| -> int { x * 2 }. Entry points MUST use with entry { } syntax, NOT entry { } alone. WRONG: entry { print("hello"); }. CORRECT: with entry { print("hello"); }. Named entry points: with entry:main { }. Global variables at module level use glob: glob config: dict = {"debug": true, "version": "1.0"}; and to modify globals inside functions use global varname; before assignment.

IMPORTS: Jac seamlessly imports from the Python ecosystem using standard import syntax. Simple import: import os; or import sys, json;. Aliased import: import datetime as dt;. From imports use braces: import from math { sqrt, pi };. From datetime: import from datetime { datetime, timedelta };. Aliased symbols: import from module { Original as Alias };. Include for Jac modules: include module_path;. DO NOT use the import:py prefix, this syntax is deprecated. WRONG: import:py os. RIGHT: import os; or import from os { path };. Any Python package works directly including sklearn, torch, numpy, requests, and all standard library modules.

ARCHETYPES: Jac provides five archetype kinds for data-centric programming. Nodes represent graph vertices: node Todo { has id: str; has title: str; has done: bool = false; has category: str = "other"; }. Nodes use has for fields, def for regular methods, and can ONLY with event clauses for abilities: node Room { has name: str; def get_info() -> str { return self.name; } can on_enter with Visitor entry { print(f"Visitor entered {self.name}"); } can on_exit with Visitor exit { print("Visitor left"); } }. Edges represent typed connections between nodes: edge Road { has distance: float; has toll: bool = false; def get_normalized(max: float) -> float { return self.distance / max; } can on_traverse with Traveler entry { print(f"Traversing {self.distance}km"); } }. Walkers are mobile agents that traverse graphs: walker Explorer { has found: list = []; can search with `root entry { visit [-->]; } can collect with Item entry { self.found.append(here); visit [-->]; } }. Objects are value types for structured data: obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } def reset() -> None { self.value = 0; } }. Objects support postinit for initialization logic. Enumerations define named constants: enum Status { PENDING, ACTIVE, COMPLETED } or with explicit values: enum Color { RED = "red", GREEN = "green", BLUE = "blue" }.

ACCESS MODIFIERS: Three access levels exist: :pub (public, default), :priv (private), :prot (protected). CRITICAL SYNTAX: The modifier comes AFTER the keyword with NO space between them. CORRECT: has:priv balance: float; and def:pub get_data() -> str { } and can:prot helper with entry { }. WRONG: has :priv x or :priv has x or has:private x or has :priv: x. Only three values are valid: :pub, :priv, :prot. NOT :protect or :protected or :private. Complete example: obj Account { has:pub name: str; has:priv balance: float = 0.0; has:prot account_id: str; def:pub deposit(amt: float) -> None { self.balance += amt; } def:priv validate() -> bool { return self.balance >= 0; } def:prot internal_transfer(target: Account, amt: float) -> None { self.balance -= amt; } }.

GRAPH OPERATIONS: Define edge types with has fields: edge Road { has distance: float; has toll: bool = false; }. Simple forward connection: a ++> b;. Bidirectional connection: a <++> b;. Typed edge without attributes: a +>:Road:+> b;. Typed edge with single attribute: a +>:Road:distance=100.5:+> b;. Typed edge with multiple attributes: a +>:Road:distance=100.5:toll=true:+> b;. Disconnect operations: del a --> b; removes specific edge, del --> b; removes all incoming edges to b, del a -->; removes all outgoing edges from a. Traversal expressions: [-->] for forward edges, [<--] for backward edges, [<-->] for both directions. Typed traversal: [-->:Road:] or [->:Road:->]. Node type filter: [-->(`?City)] selects only City nodes. Attribute filter: [-->](?population > 1000000) filters by node attributes. Edge attribute filter during traversal: [->:Road:distance < 50:->]. Combined filters: [-->(`?City)](?population > 1000000 and active == true). Chained multi-hop traversal: [here ->:Friend:-> ->:Friend:->] for friends of friends. Example setup: with entry { node_a = MyNode(name="A"); node_b = MyNode(name="B"); node_a ++> node_b; node_a +>:Road:distance=50.0:+> node_b; }.

ABILITIES AND EVENTS: Abilities use can with mandatory event clauses. CRITICAL: can ALWAYS requires with ... entry or with ... exit. For regular methods without events, use def instead. Node abilities trigger when walkers visit: node Room { can on_enter with Visitor entry { print(f"Welcome to {here.name}"); } can on_exit with Visitor exit { print("Goodbye"); } }. Walker abilities trigger based on current node type: walker DataProcessor { can start with `root entry { print("Starting from root"); visit [-->]; } can process with Person entry { print(f"Processing {here.name}"); visit [-->]; } can default with entry { print("At unknown node type"); visit [-->]; } }. Generic abilities use can name with entry { } to trigger on any node type. Execution order when walker visits node: node entry abilities run first, then walker entry abilities, then walker exit abilities, then node exit abilities. Key context variables: self refers to current archetype instance, here refers to current node being visited, visitor refers to the walker visiting (in node abilities), root refers to the user's root node, `root is the literal root node reference for spawning.

WALKER CONTROL: SPAWN SYNTAX places spawn AFTER walker instantiation and BEFORE target node. CORRECT: Greeter() spawn `root; or Explorer() spawn start_node; or walker(param=val) spawn here;. WRONG: spawn Walker() on node or Walker().spawn(node). The spawn keyword comes between the walker instance and target. VISIT queues nodes for traversal: visit [-->]; visits all forward-connected nodes, visit [-->] else { handle_leaf(); } provides fallback when no nodes to visit. DISENGAGE stops the walker completely and returns early, useful for search termination. REPORT collects return values: report {"key": value}; or report here.value;. Access reports via result.reports list after spawn. SKIP skips current iteration like continue in loops. Complete example: walker Explorer { has found: list = []; can search with `root entry { visit [-->]; } can check with Node entry { if here.name == "target" { report here; disengage; } self.found.append(here); visit [-->]; } } with entry { result = Explorer() spawn `root; print(result.reports); }. Walker with exit ability for final reporting: walker ListItems { has items: list = []; can collect with `root entry { visit [-->]; } can gather with Item entry { self.items.append(here.data); } can finish with `root exit { report self.items; } }.

AI INTEGRATION: Jac provides native LLM integration via the by llm syntax. REQUIRED SETUP: import from jaclang.core.llms { Model }; glob llm = Model(model_name="gpt-4o");. Basic function delegation: def summarize(text: str) -> str by llm; with semicolon terminator and no parentheses. WRONG: def func() -> str by llm() with empty parens. WRONG: can func by llm without proper function syntax. With explicit model reference: def translate(text: str, target: str) -> str by llm(model=llm);. Method in object: obj Assistant { def answer(q: str) -> str by llm; }. Structured output returns typed objects: obj Analysis { has sentiment: str; has topics: list[str]; } def analyze(text: str) -> Analysis by llm;. Advanced reasoning: by llm(method="Reason") for chain-of-thought, by llm(method="ReAct") for tool-using agents. Tool use: def answer(q: str) -> str by llm(tools=[get_time, search_web]);. Semstrings provide semantic hints: has description: str """semantic context for LLM""";. Streaming: def stream_story(prompt: str) -> str by llm(stream=True); returns generator. Multimodal with import from jaclang.core.llms { Image, Video }: def describe(img: Image) -> str by llm; called as describe(Image("photo.jpg")) or describe(Image("https://url/image.png")). Inline expression: response = "Explain quantum computing" by llm;. Pipeline chaining: result = text |> (|t: str| -> str { t by llm("Correct grammar") }) |> (|t: str| -> str { t by llm("Translate to Spanish") });.

FILE IO AND JSON: File operations use standard Python patterns accessible in Jac. Open files: f = file.open("data.txt", "r");. Read content: content = f.read();. Write content: f.write("data");. Close file: f.close();. Context manager pattern works: with open("file.txt", "r") as f { data = f.read(); }. JSON serialization: import json; json_str = json.dumps({"key": "value"}); parsed = json.loads(json_str);. File path operations: import from os { path }; full_path = path.join("dir", "file.txt");.

CLOUD AND API: Start server with jac serve file.jac or jac start file.jac. Walkers automatically become API endpoints at /walker/WalkerName. CRITICAL: __specs__ MUST be a nested obj with static has fields, NOT a dict literal. CORRECT: walker MyEndpoint { has data: str; obj __specs__ { static has methods: list = ["GET", "POST"]; static has auth: bool = true; static has path_prefix: str = "/api/v1/custom"; static has as_query: list = ["param1"]; } can handle with `root entry { report {"status": "ok", "data": self.data}; } }. WRONG: __specs__ = {"methods": ["GET"]}. The report statement returns response data to the client. File upload uses UploadFile type in walker has fields. Authentication enabled with auth: bool = true in __specs__. Query parameters specified with as_query: list = ["param_name"];. Path parameters via path_prefix with placeholders. Fullstack organization: use cl { } blocks for frontend code that compiles to JavaScript, sv { } blocks for backend code that compiles to Python, all in the same .jac file or split into .cl.jac files for larger projects.

WEBSOCKET: Enable websocket endpoints with methods: ["websocket"] in __specs__. Socket methods for real-time communication: socket.notify_users(user_ids, message) sends to specific users, socket.notify_channels(channel_names, message) broadcasts to channels, socket.notify_clients(client_ids, message) sends to specific client connections. Walker handles websocket events: walker ChatHandler { obj __specs__ { static has methods: list = ["websocket"]; } can handle with `root entry { message = self.payload; socket.notify_channels(["general"], message); } }.

WEBHOOKS: Configure webhook endpoints with __specs__ webhook settings specifying type (header, query, or body) and name for signature verification. Endpoint available at /webhook/walker/{walker_name}. Example: walker GithubWebhook { obj __specs__ { static has methods: list = ["POST"]; static has webhook: dict = {"type": "header", "name": "X-Hub-Signature-256"}; } can handle with `root entry { event = self.payload; report {"received": true}; } }.

SCHEDULER: Schedule walkers with __specs__ schedule configuration. Cron schedule: static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0"};. Interval schedule: static has schedule: dict = {"trigger": "interval", "seconds": 30};. One-time date schedule: static has schedule: dict = {"trigger": "date", "run_date": "2024-12-31T23:59:59"};. Scheduled walkers should have static has private: bool = true; to prevent external API access. Example: walker DailyReport { obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0"}; static has private: bool = true; } can run with `root entry { generate_report(); } }.

ASYNC: Async walkers and functions for concurrent operations. Declare async walker: async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }. Async functions: async def fetch_data(url: str) -> dict { response = await http_get(url); return response; }. Task management: task = create_task(async_operation()); status = task.__jac__.status; reports = task.__jac__.reports; error = task.__jac__.error;. Await multiple: results = await gather(task1, task2, task3);.

PERMISSIONS: Access the __jac__ anchor on any node for permission operations. Permission levels from jaclang.core.permissions: NoPerm, ReadPerm, ConnectPerm, WritePerm. GRANT permissions: node.__jac__.grant(target_root, WritePerm); or node.__jac__.grant(user_root, ReadPerm);. REVOKE permissions: node.__jac__.revoke(target_root);. CHECK access: node.__jac__.check_access(some_root, ReadPerm) returns bool. WRONG: grant(node, perm). RIGHT: node.__jac__.grant(root, WritePerm). Custom access control by defining __jac_access__ method: node SecureData { has secret: str; has allowed_roots: list = []; can __jac_access__(caller: Root) -> bool { return caller in self.allowed_roots; } }. Permission inheritance flows through graph connections.

PERSISTENCE: Nodes connected to root automatically persist across requests. Manual save operations: node = here ++> Item(name="test"); save(node); commit();. Reference nodes by ID: item = &item_id;. Delete and commit: del item; commit();. Commit specific type: commit(Item);. Global nodes use glob keyword for persistent state: glob counter: Counter = Counter();. Transaction pattern: try { node.value = new_value; commit(); } except { rollback(); }. Query persisted nodes: items = query(Item, filter=lambda i: i.active);.

TESTING: Test blocks define unit tests inline. Basic test: test addition { result = 2 + 2; assert result == 4; }. Assert fails test on false condition. Check provides soft assertion that logs but continues: test validation { check value > 0, "Value should be positive"; assert value < 100; }. Walker testing: test walker_collects_data { root ++> DataNode(value=1); root ++> DataNode(value=2); result = root spawn Collector(); assert len(result.reports) == 2; assert sum(result.reports) == 3; }. Run tests with jac test file.jac.

STANDARD LIBRARY: Built-in functions include print, input, range, len, enumerate, type, str, int, float, list, dict, set, tuple, sorted, reversed, zip, map, filter, any, all, min, max, sum, abs, round. String methods: upper(), lower(), strip(), split(sep), join(iterable), replace(old, new), startswith(prefix), endswith(suffix), find(sub), format(). List methods: append(item), extend(iterable), insert(index, item), remove(item), pop(index), sort(), reverse(), index(item), count(item), copy(), clear(). Dict methods: keys(), values(), items(), get(key, default), update(other), pop(key), setdefault(key, default), clear(), copy(). Set methods: add(item), remove(item), discard(item), union(other), intersection(other), difference(other).

JSX AND FRONTEND: Jac supports reactive UIs that compile to JavaScript within cl { } blocks. SERVER BLOCK defines backend: sv { walker get_data { obj __specs__ { static has methods: list = ["GET"]; static has auth: bool = false; } can fetch with `root entry { report {"message": "Hello from backend"}; } } }. CLIENT BLOCK defines frontend: cl { has count: int = 0; has data: str = ""; can with entry { response = fetch("/walker/get_data"); data = response.get("data", ""); } can with [count] entry { print(f"Count changed: {count}"); } can with exit { print("Cleanup"); } def increment() -> None { count += 1; } <div><p>f"Count: {count}"</p><button onClick={increment}>"+"</button></div> }. Mount effect runs on component mount: can with entry { }. Dependency effect runs when dependency changes: can with [dep] entry { }. Multiple dependencies: can with (a, b) entry { }. Cleanup effect runs on unmount: can with exit { }. JSX syntax: <Component prop={value} />, {expression} for interpolation, onClick={handler} for events. Component definition: cl { def:pub Greeting(props: dict) -> any { return <h1>Hello, {props.name}!</h1>; } def:pub app() -> any { return <div><Greeting name="Alice" /><Greeting name="Bob" /></div>; } }. File organization: single .jac file with sv { } and cl { } blocks for small apps, or split to .cl.jac files for larger projects with components/*.cl.jac and hooks/*.cl.jac structure.

DEPLOYMENT: Docker deployment: FROM python:3.11-slim; RUN pip install jaclang; COPY . /app; WORKDIR /app; CMD ["jac", "serve", "main.jac"]. Kubernetes deployment with deployment.yaml, service.yaml, and ingress.yaml manifests. Environment variables: DATABASE_URL for database connection, JAC_SECRET_KEY for authentication secrets, OPENAI_API_KEY for LLM integration, JAC_HOST and JAC_PORT for server binding. Production configuration in jac.toml: [server] host = "0.0.0.0" port = 8000 workers = 4. Scale with jac start --scale for Kubernetes deployment.

PATTERNS: Single-file fullstack pattern combines frontend and backend in one .jac file: sv { node Todo { has id: str; has title: str; has done: bool = false; } walker ListTodos { has todos: list = []; can collect with `root entry { visit [-->]; } can gather with Todo entry { self.todos.append({"id": here.id, "title": here.title, "done": here.done}); } can report_all with `root exit { report self.todos; } } walker AddTodo { has title: str; can create with `root entry { new_todo = here ++> Todo(id=uuid(), title=self.title); report {"id": new_todo[0].id, "title": self.title}; } } } cl { has todos: list = []; has new_title: str = ""; can with entry { result = root spawn ListTodos(); todos = result.reports[0] if result.reports else []; } def add_todo() -> None { if new_title { result = root spawn AddTodo(title=new_title); todos = todos + [result.reports[0]]; new_title = ""; } } <div class="todo-app"><input value={new_title} onChange={|e| { new_title = e.target.value; }} /><button onClick={add_todo}>"Add"</button><ul>{todos.map(|t| { <li key={t["id"]}>{t["title"]}</li> })}</ul></div> }. Graph traversal with collection pattern: walker Collector { has results: list = []; can start with `root entry { visit [-->]; } can collect with Item entry { if here.active { self.results.append(here); } visit [-->]; } can finish with `root exit { report self.results; } }. AI-powered processing: import from jaclang.core.llms { Model }; glob llm = Model(model_name="gpt-4o"); obj Summary { has main_points: list[str]; has sentiment: str; has word_count: int; } def analyze_document(text: str) -> Summary by llm; walker ProcessDocuments { can process with Document entry { summary = analyze_document(here.content); here.summary = summary; report {"id": here.id, "sentiment": summary.sentiment}; visit [-->]; } }. API endpoint walker with full __specs__: walker UserProfile { has user_id: str; obj __specs__ { static has methods: list = ["GET", "PUT"]; static has auth: bool = true; static has path_prefix: str = "/api/v1/users"; static has as_query: list = ["user_id"]; } can get_profile with `root entry { user = find_user(self.user_id); if user { report {"id": user.id, "name": user.name, "email": user.email}; } else { report {"error": "User not found"}; } } }.