Jac is a onelang that supersets Python and JavaScript, enabling developers to build fullstack applications spanning frontend, backend, and AI under one unified language. Jac compiles to Python for backend and AI workloads while compiling to JavaScript for frontend, with seamless interoperability between both targets. Write once, deploy anywhere. The language uses curly braces for blocks and semicolons for statement termination while maintaining Python-compatible semantics. Primitive types include int float str bool bytes any. Collections use type parameters: list[T] dict[K,V] set[T] tuple[T,...] frozenset[T]. Type unions use the pipe operator: int | None. Type annotations appear with has for fields (has x: int) and arrow for returns (-> str). Control flow uses if/elif/else with braces: if x > 0 { print("positive"); } elif x < 0 { print("negative"); } else { print("zero"); }. Loops use for item in collection { } and while condition { }. Pattern matching uses match value { case pattern => body }. Standalone functions use def: def calculate_relevance(item: Item, query: str) -> int { return len(query); }. IMPORTANT: can is ONLY for abilities with event clauses (can name with Type entry), never for standalone functions. Lambdas use lambda params -> type { body } or lambda params: expression for single expressions. The entry point uses with entry { } at module level: with entry { x = 5; print(x); }. Global variables use glob at module level: glob config: dict = {"debug": True, "version": "1.0.0"}; - read globals directly by name through LEGB resolution, but to modify a global inside a function use global varname; declaration first.
Jac seamlessly imports from the Python ecosystem - any Python library works directly with zero configuration. Simple import: import os;. Multiple imports: import sys, json;. Aliased import: import datetime as dt;. From import with braces: import from math { sqrt, pi }. Include for Jac modules: include module_path;. Import from sklearn, torch, numpy, pandas, or any Python package: import from sklearn.ensemble { RandomForestClassifier }. The import system bridges Python and Jac seamlessly, allowing mixed codebases.
Archetypes define the core building blocks. Nodes represent graph vertices with has for fields, def for methods, and can with entry/exit for abilities: node Person { has name: str; has age: int; def get_info() -> str { return f"{self.name}, {self.age}"; } can greet with Visitor entry { print(f"Hello from {self.name}"); } }. Edges represent typed connections between nodes: edge Friend { has since: int; has strength: float = 1.0; def get_normalized(max_weight: float) -> float { return self.strength / max_weight; } }. Walkers traverse graphs with has for state, can with entry/exit for traversal abilities: walker DataProcessor { has data: str; can start with `root entry { print("Starting from root"); visit [-->]; } can process with Person entry { print(f"Processing {here.name}"); visit [-->]; } }. Objects are value types with def for methods: obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } def reset() -> None { self.value = 0; } }. Objects support postinit for initialization logic. Enums define enumerations: enum Color { RED = "red", GREEN = "green", BLUE = "blue" } or with auto values: enum Status { PENDING, ACTIVE, COMPLETED }.
Access modifiers control visibility. :pub makes members public (default): has:pub name: str; or def:pub get_data() -> dict { }. :priv makes members private: has:priv secret: str; or def:priv internal_process() { }. :protect makes members protected for inheritance: has:protect config: dict;. Apply to archetypes: walker:priv MyWalker { } or node:pub SharedNode { }.
Graph operations use specialized operators. Connect operators: ++> forward connection, <++ reverse connection, <++> bidirectional connection. Basic connection: node_a ++> node_b;. Typed connection syntax places edge type between +>: and :+> with spaces: node_a +>: Friend :+> node_b;. With attributes using parentheses: node_a +>: Friend(since=2020, strength=0.9) :+> node_b;. Typed patterns: +>: EdgeType :+> forward, <+: EdgeType :<+ reverse, <+: EdgeType :+> bidirectional. Disconnect with del: del node_a ++> node_b;. Traverse operators use brackets: [-->] all outgoing, [<--] all incoming, [<-->] bidirectional. Typed traversal has no spaces: [->:Friend:->] or [->:Friend:since > 2020:->]. Node type filter: [-->(`?Person)] filters to Person nodes. Attribute filter: [-->](?age >= 18) or combined [->:Friend:->](?status == "active"). Example: adults = [-->](?age >= 18); recent_friends = [->:Friend:since > 2020:->]; friends_of_friends = [here ->:Friend:-> ->:Friend:->];.
Abilities use can with event clauses - CRITICAL: can ALWAYS requires "with ... entry" or "with ... exit", use def for regular methods. Walker abilities: can start with `root entry { visit [-->]; } triggers when walker enters root. Node abilities: can on_enter with Visitor entry { print("Entered"); } triggers when Visitor walker enters. Generic abilities: can on_any with entry { log("Visited"); } triggers on any type. Exit abilities: can cleanup with `root exit { report self.collected; }. Execution order: node entry abilities run first, then walker entry abilities, then walker exit abilities, then node exit abilities. Keywords: self references the current archetype instance; here references the current node being visited; visitor references the walker visiting a node; props accesses walker properties from node context; root is the graph root node; `root is the root type for pattern matching.
Walker control manages graph traversal. Spawn starts a walker: result = root spawn DataCollector(); or result = DataCollector() spawn root;. Visit queues nodes for traversal: visit [-->]; visits all outgoing neighbors, visit [->:Friend:->]; visits via Friend edges, visit [-->] else { print("No neighbors"); } handles empty case. Disengage stops the walker immediately: if done { disengage; }. Report returns values accessible via result.reports: report here.value; continues execution, report {"status": "complete"}; for structured data. Skip skips the current node: if not valid { skip; }. Complete traversal example: walker DataCollector { has items: list = []; can collect with `root entry { visit [-->]; } can gather with Item entry { self.items.append(here.data); visit [-->]; } can finish with `root exit { report self.items; } } with entry { root ++> Item(data="first"); root ++> Item(data="second"); result = root spawn DataCollector(); print(result.reports[0]); }.
AI integration uses by llm() for LLM-powered functions. Basic delegation: def classify_sentiment(text: str) -> str by llm;. Chain-of-thought reasoning: def solve_problem(problem: str) -> str by llm(method="Reason");. ReAct for reasoning with actions: def research(query: str) -> str by llm(method="ReAct");. Model selection: glob llm = Model(model_name="gpt-4o-mini"); then def answer(q: str) -> str by llm(model=llm);. Tool use: def get_current_time() -> str { import datetime; return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"); } then def answer(question: str) -> str by llm(tools=[get_current_time]);. Semstrings provide semantic context: """Answer customer questions about products.""" def support_agent(question: str) -> str by llm;. Structured output with enums: enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL } then def analyze(text: str) -> Sentiment by llm;. Multimodal: import from byllm { Image, Video } then def describe_image(image: Image) -> str by llm; used as describe_image(Image("photo.jpg")) or describe_image(Image("https://example.com/image.png")). Streaming: def stream_story(prompt: str) -> str by llm(stream=True); then for chunk in stream_story("Tell me a story") { print(chunk, end=""); }. Pipeline: result = text |> (lambda t: str -> str: t by llm("Correct grammar")) |> (lambda t: str -> str: t by llm("Translate to Spanish"));. Include context: glob company_info = "Company: TechCorp..."; then def support(q: str) -> str by llm(incl_info={"context": company_info});.
File I/O and JSON use standard operations. File operations: f = file.open("data.txt", "r"); content = f.read(); f.close();. Write: f = file.open("output.txt", "w"); f.write("Hello"); f.close();. JSON: import json; data = json.loads('{"key": "value"}'); text = json.dumps(data);.
Cloud and API features enable fullstack development - backend APIs and frontend UIs in one codebase. Start server with jac serve file.jac (or jac start file.jac). Walkers automatically become API endpoints. Configure with __specs__ as nested obj with static has fields: walker CreateTodo { has title: str; obj __specs__ { static has auth: bool = True; static has methods: list = ["POST"]; } can create with `root entry { new_todo = here ++> Todo(title=self.title); report new_todo; } }. Response uses report. File upload: walker Upload { has file: UploadFile; can process with `root entry { content = self.file.read(); report {"size": len(content)}; } }. Client/server code can live in one .jac file using cl { } for frontend and sv { } for backend blocks, or optionally split into separate .cl.jac files for larger projects. Endpoint example: walker ListTodos { obj __specs__ { static has auth: bool = False; static has methods: list = ["GET"]; } has todos: list = []; can collect with `root entry { visit [-->]; } can gather with Todo entry { self.todos.append({"id": here.id, "title": here.title, "done": here.done}); } can finish with `root exit { report self.todos; } }.
WebSocket support uses methods: ["websocket"] in __specs__. Walker: walker LiveUpdates { obj __specs__ { static has methods: list = ["websocket"]; } can stream with `root entry { socket.notify_users(["user1"], {"event": "update"}); socket.notify_channels(["general"], {"message": "broadcast"}); socket.notify_clients({"global": True}); } }.
Webhooks configure external service callbacks. Specs: obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Webhook-Secret"}; }. Types: header checks header value, query checks query parameter, body checks body field. Endpoint: /webhook/walker/{walker_name}.
Scheduler enables timed execution. Cron: obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0"}; static has private: bool = True; }. Interval: {"trigger": "interval", "seconds": 30}. Date: {"trigger": "date", "run_date": "2024-12-31T23:59:59"}. Mark scheduled walkers private: True to prevent external access.
Async operations support concurrent execution. Async walker: async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }. Async functions: async def fetch_data(url: str) -> dict { return await http_get(url); }. Task status: task = create_task(DataFetcher(url="...")); later check task.__jac__.status, task.__jac__.reports, task.__jac__.error.
Permissions control access to graph nodes. Levels: NoPerm (no access), ReadPerm (read only), ConnectPerm (read and connect), WritePerm (full access). Grant access: _.allow_root(node, target_root, WritePerm); or grant(node, ReadPerm);. Revoke: _.disallow_root(node, target_root); or revoke(node);. Custom access logic: def __jac_access__(self, accessor) -> bool { return accessor.role == "admin"; }.
Persistence automatically saves nodes connected to root. Auto-persist: root ++> MyNode(data="saved"); automatically persists. Manual save: save(node); then commit(); or commit(NodeType); for type-specific. Global nodes: glob shared_config = Config();. References by ID: node_ref = &"n::abc123"; retrieves node by ID.
Testing uses test blocks with assertions. Test block: test walker_collects_data { root ++> DataNode(value=1); root ++> DataNode(value=2); result = root spawn Collector(); assert len(result.reports) == 3; assert sum(result.reports) == 6; }. Assert fails test on false. Check is soft assertion that continues: check result > 0, "Should be positive";.
Standard library includes Python builtins. Functions: print input range len enumerate type str int float list dict set. String methods: upper lower strip split join replace find startswith endswith format. List methods: append extend insert remove pop sort reverse index count copy clear. Dict methods: keys values items get update pop setdefault clear copy.
JSX and frontend enable reactive UIs that compile to JavaScript. Components use JSX tags: def Button(props: dict) -> any { return <button onClick={props.onClick}>{props.label}</button>; }. Self-closing: <Input />. Fragments: <> <Child1 /> <Child2 /> </>. Expression interpolation: {expression}. Spread attributes: <Component {...props} />. Event handlers: onClick={handler} onChange={handleChange}. Import React hooks: import from react { useState, useEffect }. File organization is flexible: put everything in one .jac file with cl { } blocks for simplicity, or optionally split into .cl.jac files (e.g., components/Button.cl.jac, hooks/useAuth.cl.jac) for larger projects - .cl.jac files compile entirely to JavaScript. Both approaches share types and interfaces seamlessly. State with has: cl { def:pub Counter() -> any { has count: int = 0; return <button onClick={lambda -> None { count = count + 1; }}>{count}</button>; } }. Effects with can: cl { def:pub Timer() -> any { has seconds: int = 0; can with entry { intervalId = setInterval(lambda -> None { seconds = seconds + 1; }, 1000); } can with exit { clearInterval(intervalId); } return <p>Seconds: {seconds}</p>; } }. Dependency effects: can with [dep] entry { } runs when dep changes, can with (a, b) entry { } for multiple deps. Full component: cl { def:pub Greeting(props: dict) -> any { return <h1>Hello, {props.name}!</h1>; } def:pub app() -> any { return <div><Greeting name="Alice" /><Greeting name="Bob" /></div>; } }.
Deployment uses standard containerization. Dockerfile: FROM python:3.11-slim then RUN pip install jaclang then COPY . /app then WORKDIR /app then CMD ["jac", "serve", "main.jac"]. Kubernetes deployment with replicas, service, ingress. Environment variables: DATABASE_URL for database connection, JAC_SECRET_KEY for authentication, OPENAI_API_KEY for LLM access. Commands: jac serve file.jac starts server, jac serve --faux prints API docs.
Patterns demonstrate complete solutions. Single-file fullstack puts entire app in one .jac file: sv { node Todo { has id: str; has title: str; has done: bool = False; } walker ListTodos { obj __specs__ { static has methods: list = ["GET"]; } has todos: list = []; can collect with `root entry { visit [-->]; } can gather with Todo entry { self.todos.append({"id": here.id, "title": here.title}); } can finish with `root exit { report self.todos; } } } cl { def:pub TodoList() -> any { has todos: list = []; can with entry { result = root spawn ListTodos(); todos = result.reports[0] if result.reports else []; } return <ul>{[<li key={t["id"]}>{t["title"]}</li> for t in todos]}</ul>; } def:pub app() -> any { return <div><h1>Todos</h1><TodoList /></div>; } }. Graph traversal with collection: walker FindAdults { has adults: list = []; can start with `root entry { visit [-->]; } can check with Person entry { if here.age >= 18 { self.adults.append(here); } visit [-->]; } can finish with `root exit { report self.adults; } }. AI-powered processing: glob llm = Model(model_name="gpt-4o-mini"); enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL } """Analyze the sentiment of customer feedback.""" def analyze_feedback(text: str) -> Sentiment by llm; walker ProcessFeedback { can process with Feedback entry { here.sentiment = analyze_feedback(here.text); report {"id": here.id, "sentiment": here.sentiment}; } }. API endpoint with full specs: walker CreateUser { has email: str; has name: str; obj __specs__ { static has auth: bool = True; static has methods: list = ["POST"]; } can create with `root entry { new_user = here ++> User(email=self.email, name=self.name); report {"id": new_user.id, "email": new_user.email}; } }.