JAC LANGUAGE REFERENCE v0.9.13

═══════════════════════════════════════════════════════════════════════════════

1. TYPES

Primitives: int float str bool bytes any
Containers: list[T] dict[K,V] set[T] tuple
Unions: int | None (not int?; no Optional syntax)
Booleans: True/False (capitalized; true/false pass syntax check but FAIL at runtime)
Declaration: has name: str; has count: int = 0;
Return type: def f() -> int { return 1; }
Non-default has fields MUST precede default has fields in same archetype.
WRONG: node N { has x: int = 0; has y: str; }
RIGHT: node N { has y: str; has x: int = 0; }

2. CONTROL FLOW

If/elif/else: if cond { } elif cond { } else { }
For-in: for x in items { }; for (i, x) in enumerate(items) { } (parens required)
Range for: for i=0 to i<10 by i+=1 { }
While: while cond { }
Match/case: match x { case 1: print("one"); case _: print("other"); }
Cases use COLON then statements, NOT braces.
WRONG: case 1 { stmt; }
RIGHT: case 1: stmt;
Try/except: try { x = 1 / 0; } except ZeroDivisionError as e { print("caught"); } finally { print("done"); }
Uses except not catch; braces around all blocks.
No pass keyword: use empty block {} or comment.
Tuple unpacking: (a, b) = func(); parentheses required around left side.

3. FUNCTIONS AND EXPRESSIONS

Definition: def name(p: T) -> R { return val; }
Lambda expression form: lambda x: int -> int : x * 2 (body MUST be pure expression, no assignments)
Lambda block form: lambda x: int -> int { return x * 2; } (MUST have return statement)
Lambda multi-param: lambda x: int, y: int -> int : x + y
Lambda with assignment MUST use block form: lambda e: any -> None { input_val = e.target.value; }
WRONG: lambda e: any -> None : input_val = e.target.value
RIGHT: lambda e: any -> None { input_val = e.target.value; }
Global: glob var: T = val; (module level; persists)
Pipe: "hello world" |> print; (forward pipe, left becomes arg to right)
F-strings: f"Hello {name}!"
Docstrings: before declarations, not inside function bodies.

4. IMPORTS

Plain import: import os; import json; (semicolon required)
Selective: import from math { sqrt } (no semicolon after brace)
Alias: import from datetime { datetime as dt }
Include: include module;
Packages require __init__.jac (like Python's __init__.py).
WRONG: import from math { sqrt };
RIGHT: import from math { sqrt }

5. ARCHETYPES

Node: node Todo { has title: str; has completed: bool = False; }
Edge: edge Friend { has since: int; has strength: float = 1.0; }
Walker: walker W { has param: int = 0; can act with `root entry { visit [-->]; } }
Object: obj Calculator { has value: int = 0; def add(n: int) -> int { self.value += n; return self.value; } }
Enum: enum Color { RED = "red", GREEN = "green", BLUE = "blue" }
Enum auto: enum Status { PENDING, ACTIVE, COMPLETED }
Inheritance: obj Dog(Animal) { }; walker W2(W1) { }; node Child(Parent) { }
Impl blocks: walker Creator { can create with `root entry; } then impl Creator.create { print("created"); }
Postinit: obj MyObj { has x: int = 0; has y: int by postinit; def postinit { self.y = self.x * 2; } }
Use can for abilities (with entry/exit); use def for regular methods.
Ability names: never name abilities list/dict/str/int or other builtins; use fetch/get/handle instead.

6. ACCESS CONTROL

has:priv f: T; OR has :priv f: T; (both valid)
def:pub method() { }; can:protect handler with entry { }
Only three levels: :pub :priv :protect
Walker-level: walker:priv W { }

7. GRAPH OPERATIONS

Untyped connect: root ++> A(val=1) (returns list; use [0] for single node)
Bidirectional: a <++> b
Typed forward connect: a[0] +>: E(weight=0.5) :+> b[0] (uses +>: and :+> brackets)
Typed backward connect: a[0] <+: E(weight=0.5) :<+ b[0] (uses <+: and :<+ brackets)
Connect with kwargs: root +>: E() : weight=0.5 :+> A(val=1)
Disconnect: root del--> a[0] (del attaches to arrow)
WRONG: del root --> a[0]
RIGHT: root del--> a[0]
Walrus in connect: root +>: E() :+> (end := A(val=10))
Untyped traversal: [-->] forward; [<--] backward
Typed traversal: [->:E:->] forward; [<-:E:<-] backward (uses ->: and :-> brackets)
Chained typed: [root->:E1:->->:E2:->] (chain pairs directly)
Node type filter: [-->(`?Person)]
Node attr filter: [-->](?age > 18)
Edge attr filter: [->:Friend:since > 2020:->]
WRONG typed connect: a ++> E() ++> b (++> is ONLY for untyped)
RIGHT typed connect: a +>: E() :+> b
WRONG typed traversal: [-->:E:] (-->  is ONLY for untyped)
RIGHT typed traversal: [->:E:->]
WRONG chained: [-->:E1:->-->:E2:->]
RIGHT chained: [->:E1:->->:E2:->]

8. ABILITIES

Declaration: can name with NodeType entry { }; can name with NodeType exit { }
Always requires with...entry or with...exit.
Use can for abilities; use def for regular methods.
Context variables: self = instance; here = current node; visitor = walker visiting; root = user root; `root = root type annotation
Example: node Room { can on_enter with Visitor entry { print(f"Welcome to {here}"); } can on_exit with Visitor exit { print("Goodbye"); } }

9. WALKERS

Spawn both forms valid: root spawn MyWalker(); OR MyWalker() spawn root;
Visit: visit [-->]; visit [->:E:->]; visit [-->] else { print("leaf"); }
Indexed visit: visit : 0 : [-->];
Report: report val; (collected in result.reports)
Flow: disengage (stop walker); skip (skip current node)
Result: result = root spawn W(); result.reports for collected values.
Example: node DataNode { has value: int = 0; } walker Collector { can gather with DataNode entry { report here.value; visit [-->]; } } with entry { root ++> DataNode(value=1); result = root spawn Collector(); all_values = result.reports; }

10. BY LLM (AI INTEGRATION)

No import needed; by llm is builtin.
Function form: def classify_sentiment(text: str) -> str by llm;
With parens: def f() -> str by llm();
With params: def f(x: str) -> str by llm(temperature=0.7);
With method: def f() -> str by llm(method="Reason");
Inline: response = "Explain quantum computing" by llm;
Semstrings (docstring hints): """Classify the sentiment of the text.""" def classify(text: str) -> str by llm;
Semstring on fields: has desc: str = "" """hint for LLM"""; (default value required)
Pipeline: result = text |> (lambda t: str -> str: t by llm("Correct grammar")) |> (lambda t: str -> str: t by llm("Translate to Spanish"));

11. FILE AND JSON

import json;
File: f = file.open(path, "r"); content = f.read(); f.write(s); f.close();
JSON: s = json.dumps({"a": 1}); data = json.loads(s);
NEVER use obj as variable name (keyword).
WRONG: obj = json.loads(s);
RIGHT: data = json.loads(s);
Reserved keywords as variables: obj node walker edge enum can has are ALL keywords. Never use as variable names.

12. API ENDPOINTS

CLI: jac start file.jac (NOT jac serve; serve does not exist); jac check file.jac to validate syntax.
Walkers become endpoints automatically.
Specs use obj __specs__ with static has fields (not dict literal).
walker CreateTodo { has title: str; obj __specs__ { static has methods: list = ["POST"]; static has auth: bool = True; static has path_prefix: str = "/api"; } can create with `root entry { report {"title": self.title}; } }
WRONG: obj __specs__ = {"methods": ["POST"]}
RIGHT: obj __specs__ { static has methods: list = ["POST"]; }

13. WEBSOCKET

obj __specs__ { static has methods: list = ["websocket"]; }
Notify: socket.notify_users(user_ids, message); socket.notify_channels(channel_names, message);

14. WEBHOOKS

obj __specs__ { static has webhook: dict = {"type": "header", "name": "X-Sig"}; }
Endpoint path: /webhook/walker/name

15. SCHEDULER

obj __specs__ { static has schedule: dict = {"trigger": "cron", "hour": "9"}; static has private: bool = True; }
Triggers: cron interval date

16. ASYNC

async walker DataFetcher { has url: str; async can fetch with `root entry { data = await http_get(self.url); report data; } }
async def f() { }
Task status: task.__jac__.status; task.__jac__.reports; task.__jac__.error;

17. PERMISSIONS

Grant: node.__jac__.grant(root, WritePerm);
Revoke: node.__jac__.revoke(root);
Check: node.__jac__.check_access(root, ReadPerm);
Levels: NoPerm ReadPerm ConnectPerm WritePerm

18. PERSISTENCE

Nodes connected to root auto-persist.
Save: save(node); commit();
Reference by id: &id
Delete: del node; commit();
Persistent globals: glob var: T = val;

19. TESTING

test addition_works { assert 1 + 1 == 2; }
Test names are identifiers, NOT strings. Only assert, no check keyword.
WRONG: test "my test" { }
RIGHT: test my_test { }

20. STDLIB

Builtins: print len range enumerate type str int float list dict set
String: s.upper() s.lower() s.strip() s.split() s.join(lst)
List: l.append(x) l.extend(other) l.pop() l.sort()
Dict: d.keys() d.values() d.items() d.get(k, default)

21. JSX (FULLSTACK)

Server block: sv { } (compiles to Python)
Client block: cl { } (compiles to JavaScript)
File extensions: .sv.jac (server default); .cl.jac (client default); .jac (server default)
Component: cl { def:pub App() -> any { has count: int = 0; can with entry { } can with [dep] entry { } can with exit { } def inc() { count += 1; } return <div><p>{count}</p><button onClick={inc}>+</button></div>; } }
Lifecycle mapping: can with entry { } = useEffect(()=>{}, []); can with exit { } = useEffect(()=>{ return ()=>{}; }, []); can with [dep] entry { } = useEffect(()=>{}, [dep]); can with (a, b) entry { } = useEffect(()=>{}, [a, b])
Props: cl { def:pub Greeting(props: dict) -> any { return <h1>Hello, {props.name}!</h1>; } }
Fragment: return <>{props.children}</>;
In cl{} blocks: use items.append(x) not items = items + [x] (list concat fails type check in cl{} only).

22. DEPLOY

Docker: FROM python:3.11-slim; pip install jaclang; jac start main.jac
Scale: jac start --scale -t kubernetes (requires -t flag for target)
Env vars: DATABASE_URL JAC_SECRET_KEY OPENAI_API_KEY

═══════════════════════════════════════════════════════════════════════════════

COMMON ERRORS TABLE

WRONG -> RIGHT
entry { } -> with entry { }
jac serve file.jac -> jac start file.jac
a ++> Edge() ++> b -> a +>: Edge() :+> b
[-->:E:] -> [->:E:->]
[-->:E1:->-->:E2:->] -> [->:E1:->->:E2:->]
del a --> b -> a del--> b
case 1 { stmt; } -> case 1: stmt;
true/false -> True/False
str? -> str | None
test "name" { } -> test my_name { }
obj = json.loads(s) -> data = json.loads(s)
lambda e: any -> None : x = 1 -> lambda e: any -> None { x = 1; }
lambda x: T -> T { expr } -> lambda x: T -> T { return expr; }
import from math { sqrt }; -> import from math { sqrt }
node N { has x: int = 0; has y: str; } -> node N { has y: str; has x: int = 0; }
items = items + [x] (in cl{}) -> items.append(x) (in cl{} blocks only)
obj __specs__ = {"methods": []} -> obj __specs__ { static has methods: list = []; }
pass -> {} or # comment

═══════════════════════════════════════════════════════════════════════════════

PATTERN 1: FULLSTACK SINGLE-FILE (sv/cl with typed edges)

import json;
sv {
    node Todo {
        has title: str;
        has completed: bool = False;
    }
    edge Owns {
        has since: str;
    }
    walker AddTodo {
        has title: str;
        obj __specs__ {
            static has methods: list = ["POST"];
        }
        can create with `root entry {
            root +>: Owns(since="2024") :+> Todo(title=self.title);
            report {"status": "created"};
        }
    }
    walker ListTodos {
        has items: list = [];
        obj __specs__ {
            static has methods: list = ["GET"];
        }
        can start with `root entry {
            visit [->:Owns:->];
        }
        can gather with Todo entry {
            self.items.append({"title": here.title, "completed": here.completed});
        }
        can finish with `root exit {
            report self.items;
        }
    }
}
cl {
    def:pub App() -> any {
        has todos: list = [];
        has input_val: str = "";
        async can with entry {
            result = root spawn ListTodos();
            todos = result.reports[0] if result.reports else [];
        }
        async def add_todo() -> None {
            result = root spawn AddTodo(title=input_val);
            input_val = "";
            refresh = root spawn ListTodos();
            todos = refresh.reports[0] if refresh.reports else [];
        }
        return <div>
            <input
                value={input_val}
                onChange={lambda e: any -> None { input_val = e.target.value; }}
            />
            <button onClick={lambda e: any -> None { add_todo(); }}>Add</button>
            <ul>
                {[<li>{t["title"]}</li> for t in todos]}
            </ul>
        </div>;
    }
}

PATTERN 2: WALKER GRAPH TRAVERSAL (visit/report, typed edges, disconnect)

node City {
    has name: str;
    has population: int = 0;
}
edge Road {
    has distance: float;
}
walker Explorer {
    has visited: list = [];
    can start with `root entry {
        visit [->:Road:->];
    }
    can explore with City entry {
        self.visited.append({"city": here.name, "pop": here.population});
        visit [->:Road:distance < 100.0:->] else {
            report self.visited;
        }
    }
}
walker Cleanup {
    can start with `root entry {
        nodes = [->:Road:->];
        for n in nodes {
            root del--> n;
        }
        report {"cleaned": len(nodes)};
    }
}
with entry {
    a = root +>: Road(distance=50.0) :+> (city_a := City(name="Alpha", population=1000));
    city_a +>: Road(distance=80.0) :+> City(name="Beta", population=2000);
    city_a +>: Road(distance=200.0) :+> City(name="Gamma", population=500);
    result = root spawn Explorer();
    print(result.reports);
}

PATTERN 3: API ENDPOINT WITH SPECS AND MATCH/CASE

enum Category {
    BUG,
    FEATURE,
    QUESTION
}
node Ticket {
    has title: str;
    has category: Category;
    has priority: int = 0;
}
"""Classify ticket priority based on category."""
def get_priority(cat: Category) -> int by llm;
walker CreateTicket {
    has title: str;
    has category_name: str;
    obj __specs__ {
        static has methods: list = ["POST"];
        static has auth: bool = True;
        static has path_prefix: str = "/api";
    }
    can create with `root entry {
        cat = Category.QUESTION;
        match self.category_name {
            case "bug": cat = Category.BUG;
            case "feature": cat = Category.FEATURE;
            case _: cat = Category.QUESTION;
        }
        pri = get_priority(cat);
        root ++> Ticket(title=self.title, category=cat, priority=pri);
        report {"title": self.title, "category": self.category_name, "priority": pri};
    }
}
walker ListTickets {
    has tickets: list = [];
    obj __specs__ {
        static has methods: list = ["GET"];
    }
    can start with `root entry {
        visit [-->];
    }
    can gather with Ticket entry {
        self.tickets.append({"title": here.title, "priority": here.priority});
    }
    can finish with `root exit {
        report self.tickets;
    }
}
test ticket_creation {
    root ++> Ticket(title="Test", category=Category.BUG, priority=1);
    nodes = [root-->];
    assert len(nodes) > 0;
}

═══════════════════════════════════════════════════════════════════════════════

QUICK REFERENCE: OPERATORS

++> untyped connect (returns list); <++> bidirectional untyped
+>: E() :+> typed forward connect; <+: E() :<+ typed backward connect
del--> disconnect; del<-- backward disconnect
[-->] untyped forward traversal; [<--] backward
[->:E:->] typed forward traversal; [<-:E:<-] typed backward
[->:E:attr>val:->] edge attribute filter
[-->(`?Type)] node type filter; [-->](?attr>val) node attribute filter
spawn start walker; visit move walker; report collect value
|> pipe operator; := walrus operator