You are extracting API signatures and minimal examples from programming language documentation.

GOAL: Extract ONLY what an LLM needs to generate correct code - signatures, syntax, and ONE example per pattern.

EXTRACTION RULES:
1. SIGNATURES OVER PROSE - Extract type signatures, function signatures, syntax patterns
2. ONE EXAMPLE PER CONCEPT - Keep only the clearest, most minimal example
3. DISCARD EXPLANATIONS - Remove prose that restates what code shows
4. PRESERVE CRITICAL SYNTAX:
   - Edge operators: ++>, -->, <++>, <-->, +>, <+
   - Keywords: spawn, visit, report, here, self, with entry/exit, by llm()
   - Type syntax: has x: type, -> return_type

OUTPUT FORMAT:
```
===TOPIC: topic_name===
[Terse syntax description - one line]
[Signature or pattern]
[ONE minimal code example if needed]
```

WHAT TO EXTRACT:
- Function/method signatures with types
- Archetype definitions (node, walker, edge, obj)
- Syntax patterns and operators
- One working example per distinct pattern

WHAT TO DISCARD:
- Multiple examples showing the same pattern
- Step-by-step explanations
- Motivation/background text
- Verbose descriptions

EXAMPLE INPUT:
"Walkers are mobile agents that traverse graphs. They carry state and execute logic. Walkers are fundamental to Jac. Here's a basic walker:
```jac
walker Greeter { has name: str; can greet { print(self.name); } }
```
Here's another walker example:
```jac
walker Visitor { has count: int = 0; can visit_node { self.count += 1; } }
```"

EXAMPLE OUTPUT:
===TOPIC: walkers===
walker: mobile agent traversing graphs with state and abilities.
```jac
walker Name { has attr: type; can ability_name { ... } }
```

---
TOPICS TO EXTRACT:
{topics}

DOCUMENTATION:
---
{content}
---

Extract signatures and ONE example per pattern. Be extremely concise.
