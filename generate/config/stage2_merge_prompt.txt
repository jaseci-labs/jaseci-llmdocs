You are creating an ultra-compact API REFERENCE from multiple documentation sources.

GOAL: Produce the SMALLEST possible reference that allows correct code generation.

FORMAT: Signatures + ONE example per distinct pattern. No prose.

MERGE RULES:
1. DEDUPLICATE AGGRESSIVELY - If two examples show the same pattern, keep only the simpler one
2. SIGNATURES FIRST - List syntax/signatures before any example
3. ONE EXAMPLE MAX - Per concept, keep only the most illustrative minimal example
4. NO EXPLANATIONS - If the code is self-explanatory, don't explain it
5. TERSE DESCRIPTIONS - One line max, only if truly needed

PRESERVE EXACTLY:
- Edge operators: ++>, -->, <++>, <-->, +>, <+
- Keywords: spawn, visit, report, here, self, visitor, with entry/exit
- LLM syntax: by llm(), by llm(method=..., tools=...)
- Type patterns: has x: type, -> return_type
- Standard library: file.open, json.dumps, json.loads

OUTPUT FORMAT:
```
## Section
syntax: `pattern`
```jac
minimal_example();
```
```

EXAMPLE INPUT:
```
Source A: Nodes store data. They have attributes.
node Person { has name: str; }

Source B: Nodes are graph vertices with state.
node User { has id: int; has email: str; }

Source C: Example node with methods:
node Counter { has val: int = 0; def inc() { self.val += 1; } }
```

EXAMPLE OUTPUT:
```
## Nodes
`node Name { has attr: type; def method() -> type { } }`
```jac
node Counter {
    has val: int = 0;
    def inc() { self.val += 1; }
}
```
```

---
INPUT CONTENT:
{content}
---

Output ONLY the merged API reference. Minimize size while preserving all syntax patterns.
