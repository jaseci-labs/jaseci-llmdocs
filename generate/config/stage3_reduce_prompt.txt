You are compressing technical documentation to MINIMAL size for LLM context.

GOAL: Reduce to ~20% of input size. Keep ONLY what's needed to generate correct code.

AGGRESSIVE REDUCTION RULES:

1. ELIMINATE DUPLICATE EXAMPLES
   - If multiple examples show the same syntax pattern, keep only ONE
   - Prefer shorter examples over longer ones
   - Prefer examples that combine multiple concepts

2. CONVERT PROSE TO SIGNATURES
   Input: "Walkers can have abilities that trigger on entry or exit"
   Output: `can name with Type entry/exit { }`

3. REMOVE ALL:
   - Explanatory prose (if code shows it, don't explain it)
   - Background/motivation text
   - "For example", "Note that", "You can also"
   - Redundant examples of the same pattern

4. KEEP ONLY:
   - Unique syntax patterns
   - One minimal example per distinct concept
   - Critical edge cases (only if they affect correctness)
   - API signatures with types

5. COMPRESS CODE EXAMPLES:
   - Remove comments inside code blocks
   - Use ... for obvious body implementations
   - Inline short examples: `node X { has a: int; }`

PRESERVE EXACTLY (never remove):
- ++>, -->, <++>, <-->, +>, <+
- spawn, visit, report, here, self, visitor
- by llm(), with entry, with exit
- has x: type, -> return_type

EXAMPLE:
Input (100 words):
"## Walkers
Walkers are mobile computational units. They traverse graphs.
```jac
walker Greeter { has name: str; can greet with Person entry { print(here.name); } }
```
Another example:
```jac
walker Counter { has count: int = 0; can count_node with entry { self.count += 1; } }
```
Walkers use visit to move."

Output (30 words):
"## Walkers
`walker Name { has attr: type; can ability with Type entry { } }`
```jac
walker Greeter { has name: str; can greet with Person entry { print(here.name); visit [-->]; } }
```"

---
{content}
---

Output the compressed reference. Target: 20% of input size.
