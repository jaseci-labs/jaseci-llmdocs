You are assembling a Jac language reference. Jac is a onelang that supersets Python/JavaScript for fullstack apps (frontend compiles to JS, backend/AI compiles to Python).

HARD TARGET: 18-22KB. You MUST stay under 22KB. Count your output size. If you exceed 22KB, you have failed.

OUTPUT FORMAT: Markdown (.md file).

FORMAT RULES:
- Short declarative statements, not explanations
- Show syntax, then example. No "as in" or "for example"
- Group related items with semicolons on ONE line
- Use ```jac fenced code blocks for code examples and patterns
- Inline code with backticks for syntax references in prose lines
- One line per concept where possible
- WRONG/RIGHT pairs: show only the code, minimal words
- Patterns: 3 patterns max, each under 80 lines. No verbose comments.

STRUCTURE EACH TOPIC:
Topic: brief definition
Syntax: pattern
Example: code
(Optional) Common error: wrong -> right

HIGH-FAILURE SYNTAX (must be exact -- verified with jac check):
- CLI: jac start file.jac (not jac serve); jac check file.jac (may have false positives/negatives)
- Top-level: only declarations allowed. Executable statements MUST go inside with entry { } or a function body.
- Entry: with entry { } not entry { }
- Spawn: BOTH forms valid: root spawn Walker(); AND Walker() spawn root; (use root or variable, NEVER bare keyword node)
- Import: import from module { sym } (NO semicolon after }); import module; (semicolon for plain import). Wrong: import from math, sqrt; No import:py or import:jac exists.
- LLM: def f() -> T by llm; OR by llm(); both valid. by llm(temperature=0.7) for params. No import needed.
- Access: has:priv x OR has :priv x (both valid); only :pub :priv :protect
- Permissions: node.__jac__.grant(root, Perm)
- Specs: obj __specs__ { static has methods: list = [...]; } __specs__ controls methods/path/websocket ONLY, NOT auth.
- Walker auth: :pub on walker declaration = public (no auth). Without :pub = requires auth token. WRONG: static has auth: bool = False; in __specs__.
- :pub walker root access: READ-ONLY. Graph writes silently fail when here is root. Use built-in auth for write access.
- Custom auth: make ALL walkers :pub, handle auth manually inside walker body.
- Methods: can for abilities (with entry/exit), def for regular methods
- Root type: Root (capital R) in event clauses. Backtick `root REMOVED. Union: can act with Root | MyNode entry { }
- Filters: [-->](?:Type); [-->](?:Type, attr==val). Old (`?Type) REMOVED. Comma separator.
- CLI: jac create --use client (not fullstack); jac add --npm; jac install syncs all; jac start --scale (no -t)
- Optionals: str | None, not str?
- Booleans: True/False (true/false pass syntax but FAIL at runtime)
- Lambdas: Expression: lambda x: int -> int : x * 2; Block: lambda x: int -> int { return x * 2; }; Block REQUIRES return. Expression cannot have assignments.
- Tuple unpacking: (a, b) = func(); parens required
- No pass keyword: use {} or comment
- Enumerate: for (i, x) in enumerate(items) { }; parens required
- Match/case: case V: stmt; (COLON not braces). Wrong: case 1 { }
- Typed edge CONNECT: a +>: E() :+> b; Wrong: a ++> E() ++> b (++> only untyped)
- Typed edge TRAVERSE: [->:E:->] Wrong: [-->:E:] (--> only untyped)
- Chained: [->:E1:->->:E2:->] Wrong: [-->:E1:->-->:E2:->]
- Edge attr filter: [->:Friend:since > 2020:->]
- Disconnect: a del--> b; Wrong: del a --> b;
- Untyped returns list: a ++> Node() returns list; use [0] for single
- Variable node traversal: [node_var ->:E:->] traverses from specific node
- Globals: glob var: T = val; at module level. Access by name in functions. WRONG: glob counter; inside function body.
- Lambda as arg: items.sort(key=lambda x: dict -> float : x["v"]);
- Try/except: try { } except Type as e { } finally { }; except not catch
- Inheritance: obj Child(Parent) { }; walker W(BaseW) { }
- Pipe: "hello" |> print;
- Impl blocks: impl W.ability { code }
- Postinit: has f: T by postinit; def postinit { self.f = val; }
- Walrus: root +>: E() :+> (end := A(val=10));
- Backward typed: a <+: E() :<+ b; [<-:E:<-]
- List concat in cl{}: use items.append(x) not items = items + [x] (cl{} only)
- Reserved keywords: obj node walker edge enum can has -- NEVER use as variable names
- Attribute ordering: non-default BEFORE default. Wrong: has x: int = 0; has y: str;
- Test names: identifiers not strings. Wrong: test "name" { }
- Fullstack entry: cl{} def:pub app must match [serve] base_route_app in jac.toml
- .cl.jac auto client-side (no cl{} wrapper). Do NOT include via include.
- Dev ports: --port Vite frontend (8000); --api_port backend (8001, auto-proxied)
- No ternary ?: -- use (expr) if cond else (expr)
- cl{} JS builtins: .length not len(); String(x) not str(x); parseInt(x) not int(x); Math.min/max; .trim() not .strip(); no range(); no f-strings (use +); no tuple unpacking; no new keyword; className not class
- sv import prefix for server imports in .cl.jac
- Lifecycle: useEffect(lambda -> None { func(); }, []) not can with entry
- root spawn compiles to await; function MUST be async def
- root spawn sends POST; walker __specs__ MUST include "POST"
- CSS: import "./styles.css";
- .jac/ auto-generated, never modify manually
- include in __init__.jac: full dotted paths (include pkg.module;)
- npm deps: ALL in jac.toml; NEVER npm install in .jac/client/
- Tailwind v4: tailwindcss + @tailwindcss/postcss in [dependencies.npm]
- .env: not auto-loaded; use glob _: bool = load_dotenv() or True;
- Empty lambda: lambda e: any -> None { 0; } not {}
- Docstrings before declarations, not inside bodies

TOPICS (26 sections -- keep each CONCISE, 3-8 lines max per section):

1. TYPES: primitives; collections; unions; has; return types; attribute ordering
2. CONTROL: if/elif/else; for; while; match/case (colon!); try/except (not catch); no ternary; no pass
3. FUNCTIONS: def; lambda (2 forms); pipe; f-strings; glob; top-level restriction
4. IMPORTS: import; import from { }; include; __init__.jac; wrong forms
5. ARCHETYPES: node; edge; walker; obj; enum; inheritance; impl; postinit; can vs def
6. ACCESS: :pub :priv :protect
7. GRAPH: connect (typed/untyped); disconnect; traversal (typed/untyped); filters; variable node traversal; walrus; visit indexed
8. ABILITIES: can with entry/exit; self/here/visitor/root; Root type
9. WALKERS: spawn; visit; report; disengage; skip
10. BY_LLM: by llm; semstrings; sem annotations; enum classification; multi-model (Model)
11. FILE_JSON: file.open; json.dumps/loads; keyword variable warning
12. API: jac start; walker endpoints; __specs__; :pub auth; read-only root; custom auth
13. WEBSOCKET: __specs__ methods=["websocket"]; async walker; ws:// endpoint; notify
14. WEBHOOKS: __specs__ webhook; endpoint path
15. SCHEDULER: __specs__ schedule; triggers
16. ASYNC: async walker; async def; task status
17. PERMISSIONS: grant/revoke/check_access; levels
18. PERSISTENCE: auto-persist; save; commit; references; delete
19. TESTING: test name { assert }; identifier names
20. STDLIB: builtins; string/list/dict methods
21. JSX/CLIENT: .cl.jac; sv import; useEffect; async def + root spawn; JS builtins; className; CSS; component def:pub; has = reactive state; JSX comprehensions; conditional rendering; form handling; component props/callbacks; routing (Router/Routes/Route/Link/Navigate/useNavigate from @jac/runtime); error/loading patterns
22. CLIENT_AUTH: jacSignup/jacLogin/jacLogout/jacIsLoggedIn from @jac/runtime; per-user isolation
23. JAC.TOML: all sections; tailwind config; npm deps
24. FULLSTACK_SETUP: jac create --use client; jac install; jac add --npm; .jac/ auto-gen; project structure (main.jac wiring, walkers.jac, frontend.cl.jac, components/*.cl.jac)
25. DEV_SERVER: jac start --dev; ports; proxy; --no-client
26. DEPLOY_ENV: docker; jaseci vs jaclang; jac start --scale; env vars; .env loading via glob trick

PATTERNS (include 3 complete examples, each COMPACT -- under 80 lines):

PATTERN 1: Fullstack single-file (main.jac with sv{}/cl{})
- Counter app: node, edge, 2 walkers (GetCount, Increment) with __specs__ and :pub
- sv{} imports, cl{} with def:pub app, useEffect, async def, JS builtins
- Show jac.toml. Keep cl{} block tight -- no verbose comments.

PATTERN 2: Walker graph traversal
- Cities/Roads graph. TWO separate focused walkers:
  - FindReachable: Root entry visits [-->], City entry appends + visits [->:Road:->], Root exit reports
  - DeleteRoute: takes from_city/to_city, visits filtered nodes, uses del-->
- with entry block: creates cities, typed connects, traversal from variable node, spawn both walkers
- Show [node_var ->:Road:->] and edge attribute filter

PATTERN 3: Multi-file fullstack CRUD with auth + AI
- Combine the best of CRUD + auth + AI into ONE pattern (not 3 separate ones)
- Show file structure as comments: main.jac, walkers.jac (Add/List/Toggle/Delete walkers), frontend.cl.jac (Router, auth check, data fetching, component composition)
- Include: jacLogin/jacIsLoggedIn, sem annotations with enum, by llm(), glob llm = Model(...)
- Keep each "file" section compact

COMMON ERRORS TABLE: ~30 rows, aligned WRONG -> RIGHT format. Include all critical errors.

---

EXTRACTED CONTENT:
{content}

---

VERIFIED SYNTAX (ground truth -- use these exact forms):

# Typed edges
a +>: E(weight=0.5) :+> b; # Connect
[->:E:->] # Traverse
[->:E1:->->:E2:->] # Chained
a <+: E() :<+ b; # Backward connect
[<-:E:<-] # Backward traverse
a del--> b; # Disconnect

# Filters
[-->](?:MyNode) # Type filter
[-->](?:MyNode, age > 18) # Type + attr
[-->](?age > 18) # Untyped attr
[->:Friend:since > 2020:->] # Edge attr

# Variable node traversal
neighbors = [city_a ->:Road:->];
untyped = [node_var -->];

# Match/case
match x { case 1: print("one"); case _: print("other"); }

# Lambda forms
f = lambda x: int -> int : x * 2; # Expression
f = lambda x: int -> int { return x * 2; }; # Block (MUST return)
lambda e: any -> None { input_val = e.target.value; } # Assignment = block form
lambda e: any -> None { 0; } # Empty body (not {})

# Spawn
root spawn W(); W() spawn root; # Both valid

# Import (NO semicolon after import from { })
import os;
import from math { sqrt }

# Walrus
root +>: E() :+> (end := A(val=10));

# Visit indexed
visit : 0 : [-->];

# Test
test my_test { assert 1 + 1 == 2; }

# Postinit
obj MyObj { has x: int = 0; has y: int by postinit; def postinit { self.y = self.x * 2; } }

# Glob
glob counter: int = 0;
def increment() -> int { counter += 1; return counter; }

# cl{} patterns
# sv import from walkers { W } -- sv prefix required
# useEffect(lambda -> None { myAsyncFunc(); }, []);
# async def myAsyncFunc() -> None { result = root spawn W(); }
# className not class; (expr) if cond else (expr) not ternary
# .length not len(); String(x) not str(x); + not f-strings

# Routing
# import from "@jac/runtime" { Router, Routes, Route, Link, Navigate, useNavigate }

# Client auth
# import from "@jac/runtime" { jacSignup, jacLogin, jacLogout, jacIsLoggedIn }

# Semantic annotations
# sem Analysis.sentiment = "overall emotional tone";
# def analyze(text: str) -> Analysis by llm;
# glob llm = Model(model_name="claude-sonnet-4-20250514");

# Websocket
# async walker :pub Echo { obj __specs__ { static has methods: list = ["websocket"]; } async can echo with Root entry { report here; } }
# Endpoint: ws://localhost:8000/ws/Echo

# :pub walker read-only root
# walker :pub ReadOnly { can read with Root entry { report [-->]; } } # OK
# walker :pub WriteAttempt { can write with Root entry { here +>: E() :+> N(); } } # Silently fails!

# .env loading
# import from dotenv { load_dotenv }
# glob _: bool = load_dotenv() or True;

# jac.toml
# [project]
# name = "myapp"
# entry-point = "main.jac"
# [dependencies.npm]
# jac-client-node = "1.0.4"
# [serve]
# base_route_app = "app"

---

Generate terse markdown reference. Use # headers for topics, ```jac blocks for code. Every code example MUST use verified syntax above. 26 topics + errors table + 3 patterns. HARD LIMIT: 22KB max. Match ~500 lines / 20KB density.

GOLDEN STYLE (match this density):

# 1. TYPES

`int` `float` `str` `bool` `bytes` `any`; `list[T]` `dict[K,V]` `set[T]`; `int|None` for optional

`has x: int;` `has y: str = "default";` `-> ReturnType`

`True`/`False` (true/false FAIL at runtime)

Non-default attrs MUST precede default: `has y: str; has x: int = 0;`

# 7. GRAPH

```jac
a ++> b;                              # Untyped forward
a +>: Friend(since=2020) :+> b;       # Typed forward
[->:Friend:->]                        # Typed traversal
a del--> b;                           # Disconnect
[-->](?:Person)                       # Type filter
[-->](?:Person, age > 18)             # Type+attr filter
```

WRONG: `a ++> Edge() ++> b;` `[-->:E:]` `del a --> b;`
