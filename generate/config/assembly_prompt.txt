You are assembling a Jac language reference from extracted signatures and examples.

CORE PHILOSOPHY: Jac is a onelang that supersets Python and JavaScript, enabling developers to build fullstack applications - frontend, backend, and AI - under one unified language. Jac compiles to Python for backend/AI and JavaScript for frontend, with seamless interoperability. Write once, deploy anywhere.

TARGET: 20-25KB in dense prose format. No markdown formatting.

OUTPUT FORMAT:
- Dense prose paragraphs, no markdown headers/tables/code fences
- NO blank lines between paragraphs - continuous text
- Inline code snippets within text flow
- Semicolon-separated lists for related items
- One paragraph per topic, combine related concepts
- Example: "Types: int str float bool any. Collections: list[T] dict[K,V] set[T]. Union: type1|type2."

MANDATORY TOPICS (cover all in dense prose):

1. SYNTAX & TYPES: Jac supersets Python syntax with curly braces and enhanced type system. Primitives (int, float, str, bool, bytes, any). Collections (list, dict, set, tuple, frozenset) with type params. Type unions (int | None). Type annotations (has x: type, -> return_type). Control flow (if/elif/else, for, while, match/case). Standalone functions use def: def func_name(param: type) -> return_type { body }. IMPORTANT: can is ONLY for abilities with event clauses (can name with Type entry), never for standalone functions. Lambdas (lambda params -> type { body } or lambda params: expression). Entry point (with entry { }). Global variables use glob at module level: glob config: Config = Config(); - read globals directly by name (LEGB resolution), but to modify a global use global varname; declaration first.

2. IMPORTS: Jac seamlessly imports from Python ecosystem - any Python library works directly. Simple (import os;). Multiple (import sys, json;). Alias (import datetime as dt;). From (import from math { sqrt, pi }). Include (include module_path;). Import from sklearn, torch, numpy, or any Python package with zero configuration.

3. ARCHETYPES: node (has for fields, def for methods, can with entry/exit for abilities). edge (has for fields, typed connections). walker (has for state, can with entry/exit for traversal abilities, visit, spawn). obj (value objects, def for methods, postinit). enum (enumerations with values). Include inline examples showing def for methods and can only with event clauses.

4. ACCESS MODIFIERS: :pub (public, default), :priv (private), :protect (protected). Show on both has and def.

5. GRAPH OPERATIONS: Connect operators (++> forward, <++ reverse, <++> bidirectional). Typed connect syntax: a +>: Friend :+> b (edge type between +>: and :+> with spaces). With attributes: a +>: Friend(since=2020) :+> b. Typed patterns: +>: EdgeType :+> forward, <+: EdgeType :<+ reverse, <+: EdgeType :+> bidirectional. Disconnect (del). Traverse ([-->], [<--], [<-->]). Typed traverse ([->:EdgeType:->]). Node filter ([-->(`?NodeType)]). Attribute filter ((?attr == val)). Include examples.

6. ABILITIES & EVENTS: Abilities use can with event clauses - can name with Type entry { } or can name with Type exit { }. CRITICAL: can ALWAYS requires "with ... entry" or "with ... exit" - use def for regular methods. Generic abilities use can name with entry { } to trigger on any type. Execution order (node entry -> walker entry -> walker exit -> node exit). Keywords (self, here, visitor, props, root, `root).

7. WALKER CONTROL: spawn (walker() spawn node). visit (visit [-->], visit [-->] else { }). disengage (stop walker). report (return values). skip (skip current node). Include traversal example.

8. AI INTEGRATION: by llm() basic. by llm(method="Reason") chain-of-thought. by llm(method="ReAct") reasoning with actions. by llm(model=var) model selection. by llm(tools=[funcs]) tool use. glob llm = Model(model_name="..."). Semstrings ("""description""" and :sem:). Structured output with enums/objects. Multimodal (Image(url=), Video(path=, fps=)). Include example.

9. FILE I/O & JSON: file.open(path, mode), file.read(), file.write(), file.close(). json.dumps(obj), json.loads(str).

10. CLOUD & API: Jac enables fullstack development - backend APIs and frontend UIs in one codebase. jac serve file.jac starts the server. Walkers become API endpoints automatically. __specs__ as nested obj with static has fields (obj __specs__ { static has auth: bool = False; static has methods: list = ["GET"]; }). report for response. File upload (UploadFile). Client/server code: everything can live in one .jac file using cl { } and sv { } blocks, or optionally split into separate .cl.jac files for larger projects. Include endpoint example.

11. WEBSOCKET: methods: ["websocket"] in __specs__. Socket methods (socket.notify_users(), notify_channels(), notify_clients()).

12. WEBHOOKS: __specs__ webhook config with type (header/query/body) and name. Endpoint: /webhook/walker/{name}.

13. SCHEDULER: __specs__ schedule config. Cron ({"trigger": "cron", "hour": "9", "minute": "0"}). Interval ({"trigger": "interval", "seconds": 30}). Date ({"trigger": "date", "run_date": "..."}). private: true for scheduled walkers.

14. ASYNC: async walker, async def, await. Task status (task.__jac__.status, reports, error). Task queue (create_task()).

15. PERMISSIONS: Levels (NoPerm, ReadPerm, ConnectPerm, WritePerm). Grant (_.allow_root(node, target_root, level), grant(node, level)). Revoke (_.disallow_root(node, target), revoke(node)). Custom (__jac_access__).

16. PERSISTENCE: Auto-persist if connected to root. Manual (save(node), commit(), commit(Type)). Global nodes (glob). References (&"n::id").

17. TESTING: test { } blocks. assert (fail on false). check (soft assertion).

18. STANDARD LIBRARY: print, input, range, len, enumerate, type, str, int, float, list, dict. String methods (upper, lower, strip, split, join, replace). List methods (append, extend, insert, remove, pop, sort, reverse). Dict methods (keys, values, items, get, update, pop).

19. JSX & FRONTEND: Jac supports JSX syntax for building reactive UIs that compile to JavaScript. Components use JSX tags (<Component prop={value} />). Self-closing tags (<Input />). Fragments (<> </>). Expression interpolation ({expression}). Spread attributes ({...props}). Event handlers (onClick={handler}). Import React hooks (import from react { useState, useEffect }). File organization is flexible: put everything in one .jac file with cl { } blocks for simplicity, or optionally split into .cl.jac files (e.g., components/Button.cl.jac, hooks/useAuth.cl.jac) for larger projects - .cl.jac files compile entirely to JavaScript. Both approaches share types and interfaces seamlessly. Example: cl { def Button(props: ButtonProps) { return <button onClick={props.onClick}>{props.label}</button>; } }.

20. DEPLOYMENT: Docker (FROM python, pip install jaclang, jac serve). Kubernetes (deployment, service, ingress). Environment variables (DATABASE_URL, JAC_SECRET_KEY, OPENAI_API_KEY).

21. PATTERNS: Include 3-4 complete inline examples. Single-file fullstack: entire app in one .jac file with cl { } for frontend, sv { } for backend, walkers for API. Optional multi-file structure for larger projects: main.jac (backend), components/*.cl.jac (React components), hooks/*.cl.jac (custom hooks). Graph traversal with collection pattern. AI-powered processing with by llm(). API endpoint walker with __specs__.

CRITICAL SYNTAX TO PRESERVE EXACTLY:
- Connect: ++>, <++, <++>, +>: EdgeType :+> (spaces around type), +>: Edge(attr=val) :+> (parens only for attributes)
- Traverse: -->, <--, <-->, [->:EdgeType:->] (no spaces in typed traverse)
- Walker: spawn, visit, disengage, report, skip, here, self, visitor, props, root, `root
- Functions vs Abilities: def for standalone functions and methods, can ONLY with event clause (can name with Type entry/exit)
- LLM: by llm(), glob llm, Model, Image, Video, :sem:, method="Reason", method="ReAct"
- Types: has, def, ->, |
- Globals: glob var: Type = value; at module level, read directly by name, use global varname; to modify
- Specs: obj __specs__ { static has auth: bool; static has methods: list; }, schedule, webhook
- Onelang: cl { } (client/frontend), sv { } (server/backend), .cl.jac (optional frontend-only files), JSX syntax (<Component />, {expression})
- Permissions: NoPerm, ReadPerm, ConnectPerm, WritePerm, _.allow_root, _.disallow_root
- Async: async walker, __jac__.status, create_task
- Test: test { }, assert, check

---

EXTRACTED CONTENT:
{content}

---

Generate the complete reference as dense prose. No markdown. No blank lines. All 21 topics must be covered. Inline code examples within paragraphs. Emphasize that Jac is a onelang - one language for frontend (JSX, compiles to JS), backend (walkers, compiles to Python), and AI (by llm) - enabling fullstack development without context switching between languages.
